use clap::Parser;
use cobol_ast::AstNode;
use std::path::PathBuf;

/// Minimal C runtime shim for Phase 1.
///
/// This provides the runtime functions that generated code calls at link time.
/// For Phase 1, we only need: cobolrt_display_line, cobolrt_display,
/// cobolrt_stop_run, and a `main` entry point is generated by Cranelift.
const RUNTIME_SHIM_C: &str = r#"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void cobolrt_display_line(const char *data, unsigned int len) {
    if (data && len > 0) {
        fwrite(data, 1, len, stdout);
    }
    fputc('\n', stdout);
    fflush(stdout);
}

void cobolrt_display(const char *data, unsigned int len) {
    if (data && len > 0) {
        fwrite(data, 1, len, stdout);
    }
    fflush(stdout);
}

void cobolrt_stop_run(int status) {
    exit(status);
}

void cobolrt_accept(char *buffer, unsigned int buffer_len) {
    if (buffer && buffer_len > 0) {
        /* Pre-fill with COBOL spaces */
        memset(buffer, ' ', buffer_len);
        /* Read into a separate temp buffer to avoid overflow */
        char temp[4096];
        if (fgets(temp, sizeof(temp), stdin) != NULL) {
            size_t len = strlen(temp);
            /* Strip trailing newline */
            if (len > 0 && temp[len-1] == '\n') {
                len--;
            }
            /* Copy at most buffer_len bytes into the target */
            size_t copy_len = len < buffer_len ? len : buffer_len;
            memcpy(buffer, temp, copy_len);
            /* Remaining bytes stay as spaces from memset above */
        }
    }
}

/* ACCEPT FROM DATE: writes YYMMDD into buffer */
void cobolrt_accept_date(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[7];
    snprintf(tmp, sizeof(tmp), "%02d%02d%02d",
             t->tm_year % 100, t->tm_mon + 1, t->tm_mday);
    unsigned int copy_len = 6 < buffer_len ? 6 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM DAY: writes YYDDD into buffer */
void cobolrt_accept_day(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[6];
    snprintf(tmp, sizeof(tmp), "%02d%03d",
             t->tm_year % 100, t->tm_yday + 1);
    unsigned int copy_len = 5 < buffer_len ? 5 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM TIME: writes HHMMSSCC into buffer (CC = centiseconds) */
void cobolrt_accept_time(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[9];
    snprintf(tmp, sizeof(tmp), "%02d%02d%02d00",
             t->tm_hour, t->tm_min, t->tm_sec);
    unsigned int copy_len = 8 < buffer_len ? 8 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM DAY-OF-WEEK: writes 1-7 (1=Monday) into buffer */
void cobolrt_accept_day_of_week(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    /* tm_wday: 0=Sunday, 1=Monday, ..., 6=Saturday
       COBOL: 1=Monday, ..., 7=Sunday */
    int dow = t->tm_wday == 0 ? 7 : t->tm_wday;
    char tmp[2];
    snprintf(tmp, sizeof(tmp), "%d", dow);
    buffer[0] = tmp[0];
    if (buffer_len > 1) memset(buffer + 1, ' ', buffer_len - 1);
}

void cobolrt_move_alphanumeric(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len
) {
    if (src_len >= dest_len) {
        memcpy(dest, src, dest_len);
    } else {
        memcpy(dest, src, src_len);
        memset(dest + src_len, ' ', dest_len - src_len);
    }
}

void cobolrt_move_alphanumeric_justified(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len
) {
    /* JUSTIFIED RIGHT: right-align the data, pad with spaces on left */
    if (src_len >= dest_len) {
        /* Take rightmost dest_len chars from src */
        memcpy(dest, src + src_len - dest_len, dest_len);
    } else {
        /* Pad on left with spaces, then copy src to right portion */
        memset(dest, ' ', dest_len - src_len);
        memcpy(dest + dest_len - src_len, src, src_len);
    }
}

void cobolrt_justify_right(char *data, unsigned int len) {
    /* Right-justify alphanumeric data in place: find actual content length,
       shift to right, pad left with spaces */
    unsigned int content_end = len;
    while (content_end > 0 && data[content_end - 1] == ' ') {
        content_end--;
    }
    if (content_end < len && content_end > 0) {
        unsigned int shift = len - content_end;
        memmove(data + shift, data, content_end);
        memset(data, ' ', shift);
    }
}

void cobolrt_blank_when_zero(char *data, unsigned int len) {
    /* Check if entire field is zero (all '0' chars or spaces) */
    int all_zero = 1;
    for (unsigned int i = 0; i < len; i++) {
        if (data[i] != '0' && data[i] != ' ' && data[i] != '.' && data[i] != ',') {
            all_zero = 0;
            break;
        }
    }
    if (all_zero) {
        memset(data, ' ', len);
    }
}

void cobolrt_sign_fixup(char *data, unsigned int len, int is_leading, int is_negative) {
    /* For SIGN IS LEADING/TRAILING SEPARATE CHARACTER:
       Insert '+' or '-' at the appropriate position.
       is_leading=1: sign goes at position 0, digits shift right
       is_leading=0: sign goes at last position */
    char sign_char = is_negative ? '-' : '+';
    if (is_leading) {
        /* Shift digits right by 1, put sign at position 0 */
        memmove(data + 1, data, len - 1);
        data[0] = sign_char;
    } else {
        /* Sign at last position */
        data[len - 1] = sign_char;
    }
}

void cobolrt_initialize_alphanumeric(char *data, unsigned int len) {
    memset(data, ' ', len);
}

void cobolrt_initialize_numeric(char *data, unsigned int len) {
    memset(data, '0', len);
}

/* Convert display-format numeric (ASCII digits) to a 64-bit integer.
 * Supports signed fields using trailing overpunch encoding:
 *   Positive: last byte '0'-'9' (0x30-0x39) or '{','A'-'I' (0x7B,0x41-0x49)
 *   Negative: last byte 'p'-'y' (0x70-0x79) — digit + 0x40
 * For unsigned fields, all bytes are plain digits. */
static long long display_to_int(const char *data, unsigned int len) {
    long long result = 0;
    int negative = 0;
    for (unsigned int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c >= '0' && c <= '9') {
            result = result * 10 + (c - '0');
        } else if (c == '-') {
            /* Leading minus sign */
            negative = 1;
        } else if (c == '+' || c == ' ') {
            /* Leading plus or space — skip */
        } else if (c >= 'p' && c <= 'y') {
            /* Trailing overpunch: negative sign, digit = c - 0x40 */
            result = result * 10 + (c - 'p');
            negative = 1;
        } else if (c == '{') {
            /* Positive overpunch for 0 (some conventions) */
            result = result * 10 + 0;
        } else if (c >= 'A' && c <= 'I') {
            /* Positive overpunch for 1-9 (some conventions) */
            result = result * 10 + (c - 'A' + 1);
        }
    }
    return negative ? -result : result;
}

/* Global flag: set to 1 when an arithmetic operation overflows the
 * destination field.  Cleared on next arithmetic operation.  Read by
 * cobolrt_last_size_error(). */
static int _cobol_size_error_flag = 0;

int cobolrt_last_size_error(void) {
    int r = _cobol_size_error_flag;
    _cobol_size_error_flag = 0;
    return r;
}

void cobolrt_clear_size_error(void) {
    _cobol_size_error_flag = 0;
}

void cobolrt_set_size_error(int flag) {
    if (flag) {
        _cobol_size_error_flag = 1;
    }
}

/* Write a 64-bit integer into display format (ASCII digits, right-justified, zero-padded).
 * Negative values are encoded using trailing overpunch: last digit + 0x40.
 * Sets _cobol_size_error_flag if the value cannot fit in len digits,
 * or if the value is negative and the destination is unsigned (dest_is_signed==0). */
static void int_to_display_ex(long long value, char *data, unsigned int len, int dest_is_signed) {
    int negative = (value < 0);
    if (negative && !dest_is_signed) {
        /* Negative result into an unsigned field is always a size error */
        _cobol_size_error_flag = 1;
    }
    if (value < 0) value = -value;
    /* Check if the value fits in len digits */
    long long temp = value;
    unsigned int digits = 0;
    do { digits++; temp /= 10; } while (temp > 0);
    if (digits > len) {
        _cobol_size_error_flag = 1;
    }
    memset(data, '0', len);
    for (int i = (int)len - 1; i >= 0 && value > 0; i--) {
        data[i] = '0' + (char)(value % 10);
        value /= 10;
    }
    if (negative && len > 0) {
        /* Apply trailing overpunch to the last byte: add 0x40 */
        data[len - 1] = (char)(data[len - 1] + 0x40);
    }
}

/* Backward-compatible wrapper: assumes signed destination (no unsigned overflow check). */
static void int_to_display(long long value, char *data, unsigned int len) {
    int_to_display_ex(value, data, len, 1);
}

/* ---------- COMP (BINARY) encoding helpers ---------- */
/* Encoding constants: 0=display, 1=COMP(binary), 2=COMP-3(packed BCD) */
#define ENC_DISPLAY 0
#define ENC_COMP    1
#define ENC_COMP3   2

/* Read a big-endian signed binary integer from COMP storage. */
static long long comp_to_int(const char *data, unsigned int byte_size) {
    /* Sign-extend from the first byte */
    long long result = (signed char)data[0];
    for (unsigned int i = 1; i < byte_size; i++) {
        result = (result << 8) | ((unsigned char)data[i]);
    }
    return result;
}

/* Write a signed integer as big-endian binary into COMP storage. */
static void int_to_comp(long long value, char *data, unsigned int byte_size, int is_signed) {
    if (!is_signed && value < 0) {
        _cobol_size_error_flag = 1;
        value = -value;
    }
    for (int i = (int)byte_size - 1; i >= 0; i--) {
        data[i] = (char)(value & 0xFF);
        value >>= 8;
    }
}

/* Read a packed BCD (COMP-3) value. Last nibble is sign: 0xC=positive, 0xD=negative, 0xF=unsigned.
 * Each byte holds two BCD digits, except the last byte's low nibble is the sign. */
static long long comp3_to_int(const char *data, unsigned int byte_size) {
    long long result = 0;
    int negative = 0;
    for (unsigned int i = 0; i < byte_size; i++) {
        unsigned char b = (unsigned char)data[i];
        unsigned char hi = (b >> 4) & 0x0F;
        unsigned char lo = b & 0x0F;
        if (i == byte_size - 1) {
            /* Last byte: high nibble is last digit, low nibble is sign */
            if (hi <= 9) result = result * 10 + hi;
            if (lo == 0x0D || lo == 0x0B) negative = 1;
        } else {
            if (hi <= 9) result = result * 10 + hi;
            if (lo <= 9) result = result * 10 + lo;
        }
    }
    return negative ? -result : result;
}

/* Write a signed integer as packed BCD (COMP-3). */
static void int_to_comp3(long long value, char *data, unsigned int byte_size, int is_signed) {
    int negative = (value < 0);
    if (negative) value = -value;
    if (!is_signed && negative) {
        _cobol_size_error_flag = 1;
    }
    memset(data, 0, byte_size);
    /* Number of digit positions = byte_size * 2 - 1 (last nibble is sign) */
    int num_digits = (int)byte_size * 2 - 1;
    /* Fill digits right-to-left */
    unsigned char digits[32];
    memset(digits, 0, sizeof(digits));
    for (int i = num_digits - 1; i >= 0 && value > 0; i--) {
        digits[i] = (unsigned char)(value % 10);
        value /= 10;
    }
    /* Pack into bytes */
    int d = 0;
    for (unsigned int i = 0; i < byte_size; i++) {
        unsigned char hi = digits[d++];
        unsigned char lo;
        if (i == byte_size - 1) {
            /* Last byte: sign nibble */
            lo = (negative && is_signed) ? 0x0D : 0x0C;
        } else {
            lo = digits[d++];
        }
        data[i] = (char)((hi << 4) | lo);
    }
}

/* Generic field-to-int: dispatch based on encoding. */
static long long field_to_int(const char *data, unsigned int len, int encoding) {
    switch (encoding) {
        case ENC_COMP:  return comp_to_int(data, len);
        case ENC_COMP3: return comp3_to_int(data, len);
        default:        return display_to_int(data, len);
    }
}

/* Generic int-to-field: dispatch based on encoding. */
static void int_to_field(long long value, char *data, unsigned int len, int encoding, int is_signed) {
    switch (encoding) {
        case ENC_COMP:  int_to_comp(value, data, len, is_signed); break;
        case ENC_COMP3: int_to_comp3(value, data, len, is_signed); break;
        default:        int_to_display_ex(value, data, len, is_signed); break;
    }
}

/* Display a COMP field: convert to decimal string and write to stdout. */
void cobolrt_display_comp(const char *data, unsigned int byte_size,
                          unsigned int digits, int is_signed) {
    long long val = comp_to_int(data, byte_size);
    int negative = (val < 0);
    if (negative) val = -val;
    char buf[32];
    int len = 0;
    if (val == 0) { buf[len++] = '0'; }
    else {
        char tmp[32]; int tlen = 0;
        while (val > 0) { tmp[tlen++] = '0' + (char)(val % 10); val /= 10; }
        for (int i = tlen - 1; i >= 0; i--) buf[len++] = tmp[i];
    }
    if (negative && is_signed) { fputc('-', stdout); }
    fwrite(buf, 1, len, stdout);
    fflush(stdout);
}

/* Display a COMP-3 field: convert to decimal string and write to stdout. */
void cobolrt_display_comp3(const char *data, unsigned int byte_size,
                           unsigned int digits, int is_signed) {
    long long val = comp3_to_int(data, byte_size);
    int negative = (val < 0);
    if (negative) val = -val;
    char buf[32];
    int len = 0;
    if (val == 0) { buf[len++] = '0'; }
    else {
        char tmp[32]; int tlen = 0;
        while (val > 0) { tmp[tlen++] = '0' + (char)(val % 10); val /= 10; }
        for (int i = tlen - 1; i >= 0; i--) buf[len++] = tmp[i];
    }
    if (negative && is_signed) { fputc('-', stdout); }
    fwrite(buf, 1, len, stdout);
    fflush(stdout);
}

void cobolrt_add_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len,
    int dest_is_signed
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a + b;
    int_to_display_ex(result, dest, dest_len, dest_is_signed);
}

void cobolrt_add_numeric_enc(
    const char *src1, unsigned int src1_len, int src1_enc,
    const char *src2, unsigned int src2_len, int src2_enc,
    char *dest, unsigned int dest_len, int dest_enc,
    int dest_is_signed
) {
    long long a = field_to_int(src1, src1_len, src1_enc);
    long long b = field_to_int(src2, src2_len, src2_enc);
    long long result = a + b;
    int_to_field(result, dest, dest_len, dest_enc, dest_is_signed);
}

void cobolrt_subtract_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len,
    int dest_is_signed
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a - b;
    int_to_display_ex(result, dest, dest_len, dest_is_signed);
}

void cobolrt_subtract_numeric_enc(
    const char *src1, unsigned int src1_len, int src1_enc,
    const char *src2, unsigned int src2_len, int src2_enc,
    char *dest, unsigned int dest_len, int dest_enc,
    int dest_is_signed
) {
    long long a = field_to_int(src1, src1_len, src1_enc);
    long long b = field_to_int(src2, src2_len, src2_enc);
    long long result = a - b;
    int_to_field(result, dest, dest_len, dest_enc, dest_is_signed);
}

void cobolrt_multiply_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len,
    int dest_is_signed
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a * b;
    int_to_display_ex(result, dest, dest_len, dest_is_signed);
}

void cobolrt_multiply_numeric_enc(
    const char *src1, unsigned int src1_len, int src1_enc,
    const char *src2, unsigned int src2_len, int src2_enc,
    char *dest, unsigned int dest_len, int dest_enc,
    int dest_is_signed
) {
    long long a = field_to_int(src1, src1_len, src1_enc);
    long long b = field_to_int(src2, src2_len, src2_enc);
    long long result = a * b;
    int_to_field(result, dest, dest_len, dest_enc, dest_is_signed);
}

void cobolrt_divide_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len,
    int dest_is_signed
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    if (b == 0) {
        _cobol_size_error_flag = 1;
        /* On divide by zero, leave dest unchanged per COBOL standard */
        return;
    }
    long long result = a / b;
    int_to_display_ex(result, dest, dest_len, dest_is_signed);
}

void cobolrt_divide_numeric_enc(
    const char *src1, unsigned int src1_len, int src1_enc,
    const char *src2, unsigned int src2_len, int src2_enc,
    char *dest, unsigned int dest_len, int dest_enc,
    int dest_is_signed
) {
    long long a = field_to_int(src1, src1_len, src1_enc);
    long long b = field_to_int(src2, src2_len, src2_enc);
    if (b == 0) {
        _cobol_size_error_flag = 1;
        return;
    }
    long long result = a / b;
    int_to_field(result, dest, dest_len, dest_enc, dest_is_signed);
}

int cobolrt_compare_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}

int cobolrt_compare_numeric_enc(
    const char *src1, unsigned int src1_len, int src1_enc,
    const char *src2, unsigned int src2_len, int src2_enc
) {
    long long a = field_to_int(src1, src1_len, src1_enc);
    long long b = field_to_int(src2, src2_len, src2_enc);
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}

/* Move a numeric value between fields with potentially different encodings. */
void cobolrt_move_numeric_enc(
    const char *src, unsigned int src_len, int src_enc,
    char *dest, unsigned int dest_len, int dest_enc,
    int dest_is_signed
) {
    long long val = field_to_int(src, src_len, src_enc);
    int_to_field(val, dest, dest_len, dest_enc, dest_is_signed);
}

/* Convert display-format bytes to a 64-bit integer (public runtime function). */
long long cobolrt_display_to_int(const char *data, unsigned int len) {
    return display_to_int(data, len);
}

/* Read digits from a display buffer, skipping non-digit chars (e.g. '.').
 * Handles trailing overpunch for signed fields. */
static long long display_to_int_skip(const char *data, unsigned int len) {
    long long result = 0;
    int negative = 0;
    for (unsigned int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c >= '0' && c <= '9') {
            result = result * 10 + (c - '0');
        } else if (c >= 'p' && c <= 'y') {
            result = result * 10 + (c - 'p');
            negative = 1;
        } else if (c == '{') {
            result = result * 10 + 0;
        } else if (c >= 'A' && c <= 'I') {
            result = result * 10 + (c - 'A' + 1);
        }
        /* skip '.', spaces, etc. */
    }
    return negative ? -result : result;
}

/* Write digits to a display buffer, inserting '.' at dot_pos if >= 0. */
static void int_to_display_edited(long long value, char *data, unsigned int len,
                                   int dot_pos) {
    if (value < 0) value = -value;
    /* Count digit positions (all except the dot) */
    unsigned int num_digits = (dot_pos >= 0) ? len - 1 : len;
    /* Fill with zeros first */
    memset(data, '0', len);
    if (dot_pos >= 0 && dot_pos < (int)len) {
        data[dot_pos] = '.';
    }
    /* Write digits right-to-left, skipping the dot position */
    for (int i = (int)len - 1; i >= 0 && (value > 0 || num_digits > 0); i--) {
        if (dot_pos >= 0 && i == dot_pos) continue;
        if (value > 0) {
            data[i] = '0' + (char)(value % 10);
            value /= 10;
        } else {
            data[i] = '0';
        }
        num_digits--;
    }
}

void cobolrt_divide_scaled(
    const char *src1, unsigned int src1_len, int src1_scale,
    const char *src2, unsigned int src2_len, int src2_scale,
    char *dest, unsigned int dest_len, int dest_scale,
    int dest_dot_pos, int rounded
) {
    long long dividend = display_to_int_skip(src1, src1_len);
    long long divisor = display_to_int_skip(src2, src2_len);

    if (divisor == 0) {
        /* Division by zero: set size error flag, leave dest unchanged */
        _cobol_size_error_flag = 1;
        return;
    }

    /*
     * Scale adjustment:
     * dividend represents a value * 10^src1_scale
     * divisor represents a value * 10^src2_scale
     * result should represent value * 10^dest_scale
     *
     * result_raw = dividend / divisor (in integer terms)
     * But we need: result = (dividend / 10^src1_scale) / (divisor / 10^src2_scale) * 10^dest_scale
     * => result = dividend * 10^(dest_scale - src1_scale + src2_scale) / divisor
     */
    int scale_adjust = dest_scale - src1_scale + src2_scale;

    long long adjusted_dividend = dividend;
    if (scale_adjust > 0) {
        for (int i = 0; i < scale_adjust; i++)
            adjusted_dividend *= 10;
    } else if (scale_adjust < 0) {
        for (int i = 0; i < -scale_adjust; i++)
            adjusted_dividend /= 10;
    }

    long long result;
    if (rounded) {
        /* For rounding, compute one extra decimal place */
        long long extended = adjusted_dividend * 10 / divisor;
        result = extended / 10;
        if ((extended % 10) >= 5) result++;
    } else {
        result = adjusted_dividend / divisor;
    }

    int_to_display_edited(result, dest, dest_len, dest_dot_pos);
}

/* DIVIDE REMAINDER: remainder = dividend - quotient * divisor
 * All values are in display format. quotient_addr already has the integer quotient.
 */
void cobolrt_remainder_scaled(
    const char *dividend, unsigned int dividend_len, int dividend_scale,
    const char *divisor, unsigned int divisor_len, int divisor_scale,
    const char *quotient, unsigned int quotient_len, int quotient_scale,
    char *remainder, unsigned int remainder_len, int remainder_scale,
    int remainder_dot_pos
) {
    long long dv = display_to_int_skip(dividend, dividend_len);
    long long ds = display_to_int_skip(divisor, divisor_len);
    long long q = display_to_int_skip(quotient, quotient_len);

    /* Adjust for scales:
     * actual_dividend = dv / 10^dividend_scale
     * actual_divisor = ds / 10^divisor_scale
     * actual_quotient = q / 10^quotient_scale
     * remainder = actual_dividend - actual_quotient * actual_divisor
     * We want remainder as integer * 10^remainder_scale
     */

    /* Scale everything to remainder_scale for computation */
    long long scale_dv = dv;
    int dv_adjust = remainder_scale - dividend_scale;
    if (dv_adjust > 0) { for (int i=0; i<dv_adjust; i++) scale_dv *= 10; }
    else if (dv_adjust < 0) { for (int i=0; i<-dv_adjust; i++) scale_dv /= 10; }

    long long scale_q = q;
    int q_ds_scale = quotient_scale + divisor_scale;
    int qs_adjust = remainder_scale - q_ds_scale;
    long long q_times_ds = scale_q * ds;
    if (qs_adjust > 0) { for (int i=0; i<qs_adjust; i++) q_times_ds *= 10; }
    else if (qs_adjust < 0) { for (int i=0; i<-qs_adjust; i++) q_times_ds /= 10; }

    long long rem = scale_dv - q_times_ds;
    if (rem < 0) rem = -rem;

    int_to_display_edited(rem, remainder, remainder_len, remainder_dot_pos);
}

/* Allocate a temp buffer for literal operands in arithmetic.
 * Copies src_str into a static buffer and returns a pointer.
 */
static char _alloc_temp_buf[64];
char* cobolrt_alloc_temp(const char *src, unsigned int src_len) {
    unsigned int copy_len = src_len < 63 ? src_len : 63;
    for (unsigned int i = 0; i < copy_len; i++) _alloc_temp_buf[i] = src[i];
    _alloc_temp_buf[copy_len] = '\0';
    return _alloc_temp_buf;
}

int cobolrt_compare_alphanumeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len
) {
    unsigned int min_len = src1_len < src2_len ? src1_len : src2_len;
    for (unsigned int i = 0; i < min_len; i++) {
        unsigned char a = (unsigned char)src1[i];
        unsigned char b = (unsigned char)src2[i];
        if (a < b) return -1;
        if (a > b) return 1;
    }
    /* If one is shorter, trailing spaces are implied */
    if (src1_len < src2_len) {
        for (unsigned int i = src1_len; i < src2_len; i++) {
            unsigned char b = (unsigned char)src2[i];
            if (' ' < b) return -1;
            if (' ' > b) return 1;
        }
    } else if (src2_len < src1_len) {
        for (unsigned int i = src2_len; i < src1_len; i++) {
            unsigned char a = (unsigned char)src1[i];
            if (a < ' ') return -1;
            if (a > ' ') return 1;
        }
    }
    return 0;
}

/* ---- File I/O ---- */

/* Simple file handle table: up to 64 open files */
#define MAX_OPEN_FILES 64
static FILE *open_files[MAX_OPEN_FILES] = {0};

/* File metadata per open file */
typedef struct {
    int organization;    /* 0=seq, 1=relative, 2=indexed, 3=line-seq */
    int access_mode;     /* 0=sequential, 1=random, 2=dynamic */
    unsigned int record_size; /* fixed record size in bytes */
    long current_pos;    /* current record number (1-based) for sequential access */
} FileMetadata;
static FileMetadata file_meta[MAX_OPEN_FILES];

int cobolrt_file_open(const char *filename, unsigned int filename_len,
                      int mode, int org, int access, int rec_size) {
    /* Build null-terminated filename */
    char fname[1024];
    unsigned int copy_len = filename_len < sizeof(fname) - 1 ? filename_len : sizeof(fname) - 1;
    memcpy(fname, filename, copy_len);
    fname[copy_len] = '\0';

    const char *fmode;
    if (org == 1) {
        /* Relative files use binary mode */
        switch (mode) {
            case 0: fmode = "rb";   break; /* INPUT */
            case 1: fmode = "wb";   break; /* OUTPUT */
            case 2: fmode = "r+b";  break; /* I-O */
            case 3: fmode = "ab";   break; /* EXTEND */
            default: fmode = "rb";  break;
        }
    } else {
        switch (mode) {
            case 0: fmode = "r";  break; /* INPUT */
            case 1: fmode = "w";  break; /* OUTPUT */
            case 2: fmode = "r+"; break; /* I-O */
            case 3: fmode = "a";  break; /* EXTEND */
            default: fmode = "r"; break;
        }
    }

    FILE *fp = fopen(fname, fmode);
    if (!fp && mode == 2) {
        /* I-O mode: if file doesn't exist, create it */
        if (org == 1) {
            fp = fopen(fname, "w+b");
        } else {
            fp = fopen(fname, "w+");
        }
    }
    if (!fp) return -1;

    /* Find a free slot */
    for (int i = 0; i < MAX_OPEN_FILES; i++) {
        if (open_files[i] == NULL) {
            open_files[i] = fp;
            file_meta[i].organization = org;
            file_meta[i].access_mode = access;
            file_meta[i].record_size = (unsigned int)rec_size;
            file_meta[i].current_pos = 0;
            return i;
        }
    }
    /* No free slot */
    fclose(fp);
    return -1;
}

void cobolrt_file_close(int handle) {
    if (handle >= 0 && handle < MAX_OPEN_FILES && open_files[handle]) {
        fclose(open_files[handle]);
        open_files[handle] = NULL;
    }
}

void cobolrt_file_write_line(int handle, const char *data, unsigned int data_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    /* Write data, trimming trailing spaces, then add newline */
    int end = (int)data_len - 1;
    while (end >= 0 && data[end] == ' ') end--;
    fwrite(data, 1, (size_t)(end + 1), open_files[handle]);
    fputc('\n', open_files[handle]);
    fflush(open_files[handle]);
}

int cobolrt_file_read_line(int handle, char *buffer, unsigned int buffer_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return 1;
    char line[4096];
    if (fgets(line, sizeof(line), open_files[handle]) == NULL) {
        return 1; /* EOF — do not modify buffer */
    }
    /* Space-fill buffer before copying new data */
    memset(buffer, ' ', buffer_len);
    /* Remove trailing newline */
    size_t len = strlen(line);
    if (len > 0 && line[len - 1] == '\n') {
        line[len - 1] = '\0';
        len--;
    }
    if (len > 0 && line[len - 1] == '\r') {
        line[len - 1] = '\0';
        len--;
    }
    /* Copy into buffer, space-pad remainder */
    unsigned int copy_len = len < buffer_len ? (unsigned int)len : buffer_len;
    memcpy(buffer, line, copy_len);
    return 0; /* OK */
}

/* ---- Relative / Fixed-Record File I/O ---- */

/* Write a fixed-length record.
   For relative files in sequential mode, writes at current_pos and advances.
   For random mode, the caller must set the relative key in the record area
   before calling; here we just write at current_pos. */
void cobolrt_file_write_record(int handle, const char *data, unsigned int data_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    unsigned int rec_size = file_meta[handle].record_size;
    if (rec_size == 0) rec_size = data_len;

    /* For sequential writes, just write at current position */
    fwrite(data, 1, rec_size, open_files[handle]);
    /* Pad if data_len < rec_size */
    if (data_len < rec_size) {
        unsigned int pad = rec_size - data_len;
        char spaces[256];
        memset(spaces, ' ', sizeof(spaces));
        while (pad > 0) {
            unsigned int chunk = pad < sizeof(spaces) ? pad : sizeof(spaces);
            fwrite(spaces, 1, chunk, open_files[handle]);
            pad -= chunk;
        }
    }
    fflush(open_files[handle]);
    file_meta[handle].current_pos++;
}

/* Read a fixed-length record.
   Returns 0=success, 1=EOF/error. */
int cobolrt_file_read_record(int handle, char *buffer, unsigned int buffer_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return 1;
    unsigned int rec_size = file_meta[handle].record_size;
    if (rec_size == 0) rec_size = buffer_len;

    /* Space-fill buffer */
    memset(buffer, ' ', buffer_len);

    char temp[8192];
    if (rec_size > sizeof(temp)) rec_size = sizeof(temp);
    size_t nread = fread(temp, 1, rec_size, open_files[handle]);
    if (nread == 0) return 1; /* EOF */

    /* Copy into buffer */
    unsigned int copy_len = nread < buffer_len ? (unsigned int)nread : buffer_len;
    memcpy(buffer, temp, copy_len);
    file_meta[handle].current_pos++;
    return 0;
}

/* Rewrite (update) the most recently read record in place. */
void cobolrt_file_rewrite(int handle, const char *data, unsigned int data_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    unsigned int rec_size = file_meta[handle].record_size;
    if (rec_size == 0) rec_size = data_len;

    /* Seek back to the start of the current record */
    long pos = file_meta[handle].current_pos;
    if (pos > 0) pos--;
    fseek(open_files[handle], (long)pos * (long)rec_size, SEEK_SET);
    fwrite(data, 1, rec_size > data_len ? data_len : rec_size, open_files[handle]);
    /* Pad remainder */
    if (data_len < rec_size) {
        unsigned int pad = rec_size - data_len;
        char spaces[256];
        memset(spaces, ' ', sizeof(spaces));
        while (pad > 0) {
            unsigned int chunk = pad < sizeof(spaces) ? pad : sizeof(spaces);
            fwrite(spaces, 1, chunk, open_files[handle]);
            pad -= chunk;
        }
    }
    fflush(open_files[handle]);
    /* Re-seek past this record so sequential reading continues */
    fseek(open_files[handle], (long)(pos + 1) * (long)rec_size, SEEK_SET);
}

/* Delete a record (fill with binary zeros for relative files). */
void cobolrt_file_delete(int handle) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    unsigned int rec_size = file_meta[handle].record_size;
    if (rec_size == 0) return;

    long pos = file_meta[handle].current_pos;
    if (pos > 0) pos--;
    fseek(open_files[handle], (long)pos * (long)rec_size, SEEK_SET);
    char zeros[256];
    memset(zeros, 0, sizeof(zeros));
    unsigned int remaining = rec_size;
    while (remaining > 0) {
        unsigned int chunk = remaining < sizeof(zeros) ? remaining : sizeof(zeros);
        fwrite(zeros, 1, chunk, open_files[handle]);
        remaining -= chunk;
    }
    fflush(open_files[handle]);
    fseek(open_files[handle], (long)(pos + 1) * (long)rec_size, SEEK_SET);
}

/* START: position file to a specific relative record number.
   key_ptr points to the numeric data item containing the record number.
   key_len is the byte size of that data item. */
void cobolrt_file_start(int handle, const char *key_ptr, unsigned int key_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    unsigned int rec_size = file_meta[handle].record_size;
    if (rec_size == 0) return;

    /* Convert the display-format key to an integer */
    long long rec_num = 0;
    if (key_ptr && key_len > 0) {
        rec_num = display_to_int(key_ptr, key_len);
    }
    if (rec_num < 1) rec_num = 1;

    /* Position to record rec_num (1-based) */
    fseek(open_files[handle], (long)(rec_num - 1) * (long)rec_size, SEEK_SET);
    file_meta[handle].current_pos = (long)(rec_num - 1);
}

void cobolrt_string_append(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len,
    char *ptr, unsigned int ptr_len,
    const char *delim, unsigned int delim_len
) {
    /* If a previous source already triggered overflow, skip this source */
    if (_cobol_size_error_flag) {
        return;
    }

    /* Read the pointer value (1-based, display-format numeric) */
    long long pos = display_to_int(ptr, ptr_len);

    /* COBOL STRING: pointer < 1 or > dest_len+1 is an overflow */
    if (pos < 1 || pos > (long long)dest_len + 1) {
        _cobol_size_error_flag = 1;
        return;
    }

    /* COBOL STRING uses 1-based positioning */
    unsigned int dest_pos = (unsigned int)(pos - 1);

    /* Determine effective source length based on delimiter */
    unsigned int effective_len = src_len;
    if (delim && delim_len > 0) {
        /* DELIMITED BY <value> — scan for delimiter in source */
        for (unsigned int i = 0; i + delim_len <= src_len; i++) {
            if (memcmp(src + i, delim, delim_len) == 0) {
                effective_len = i;
                break;
            }
        }
    }
    /* If delim is NULL/0, DELIMITED BY SIZE — use full src_len */

    /* If pointer is already past destination end and there are bytes to
     * write, that's an overflow */
    if (dest_pos >= dest_len && effective_len > 0) {
        _cobol_size_error_flag = 1;
        return;
    }

    /* Copy source bytes into destination starting at dest_pos */
    unsigned int copied = 0;
    for (unsigned int i = 0; i < effective_len && dest_pos + copied < dest_len; i++) {
        dest[dest_pos + copied] = src[i];
        copied++;
    }

    /* Update the pointer value (save/restore overflow flag since
     * int_to_display clears it) */
    int saved_flag = _cobol_size_error_flag;
    long long new_pos = pos + (long long)copied;
    int_to_display(new_pos, ptr, ptr_len);
    _cobol_size_error_flag = saved_flag;

    /* If not all effective bytes fit, that's an overflow */
    if (copied < effective_len) {
        _cobol_size_error_flag = 1;
    }
}

/* ---- MOVE type conversion functions ---- */

/*
 * Numeric-to-numeric MOVE with scale alignment.
 * src/dest are display-format buffers. src_scale/dest_scale indicate digits
 * after the implied decimal point. dest_dot_pos indicates the position of a
 * literal '.' in an edited PIC (e.g. PIC 9(5).99), -1 if none.
 *
 * For example: MOVE WS-A PIC 9(5)V99 TO WS-B PIC 9(3)V9(4)
 *   src has 7 digits, scale=2 (2 after V)
 *   dest has 7 digits, scale=4 (4 after V)
 *   We align on the decimal point, pad with zeros, truncate as needed.
 */
void cobolrt_move_numeric(
    const char *src, unsigned int src_len, int src_scale, int src_dot_pos,
    char *dest, unsigned int dest_len, int dest_scale, int dest_dot_pos,
    int rounded
) {
    /* Extract the integer value from source, skipping any '.' */
    long long src_val = display_to_int_skip(src, src_len);

    /* Adjust scale: if dest has more decimal places, multiply; fewer, divide */
    int scale_diff = dest_scale - src_scale;
    long long adjusted = src_val;
    if (scale_diff > 0) {
        for (int i = 0; i < scale_diff; i++)
            adjusted *= 10;
    } else if (scale_diff < 0) {
        if (rounded && scale_diff == -1) {
            /* Round: check the last digit before truncating */
            long long remainder = adjusted % 10;
            adjusted /= 10;
            if (remainder >= 5) adjusted++;
        } else if (rounded && scale_diff < -1) {
            /* Round: compute one extra digit, check, then truncate */
            for (int i = 0; i < (-scale_diff) - 1; i++)
                adjusted /= 10;
            long long remainder = adjusted % 10;
            adjusted /= 10;
            if (remainder >= 5) adjusted++;
        } else {
            for (int i = 0; i < -scale_diff; i++)
                adjusted /= 10;
        }
    }

    /* Write the result into the destination */
    if (dest_dot_pos >= 0) {
        int_to_display_edited(adjusted, dest, dest_len, dest_dot_pos);
    } else {
        int_to_display(adjusted, dest, dest_len);
    }
}

/*
 * Numeric-to-alphanumeric MOVE.
 * Converts the numeric display value to a left-justified string.
 * Leading zeros are preserved (COBOL standard for MOVE numeric TO alpha).
 * The result is left-justified and space-padded on the right.
 */
void cobolrt_move_num_to_alpha(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len
) {
    /* Copy the display representation, left-justified */
    unsigned int copy_len = src_len < dest_len ? src_len : dest_len;
    memcpy(dest, src, copy_len);
    /* Space-pad the remainder */
    if (copy_len < dest_len) {
        memset(dest + copy_len, ' ', dest_len - copy_len);
    }
}

/*
 * Alphanumeric-to-numeric MOVE.
 * Parses the alphanumeric field as a number.
 * Non-numeric characters result in those positions being treated as zero.
 * Result is right-justified, zero-padded in the dest.
 */
void cobolrt_move_alpha_to_num(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len, int dest_dot_pos
) {
    /* Parse the source as a numeric value, ignoring non-digits except '.' */
    long long int_part = 0;
    long long frac_part = 0;
    int frac_digits = 0;
    int in_frac = 0;

    for (unsigned int i = 0; i < src_len; i++) {
        char c = src[i];
        if (c == '.') {
            in_frac = 1;
            continue;
        }
        if (c >= '0' && c <= '9') {
            if (in_frac) {
                frac_part = frac_part * 10 + (c - '0');
                frac_digits++;
            } else {
                int_part = int_part * 10 + (c - '0');
            }
        }
        /* Non-numeric chars (spaces, letters) are ignored */
    }

    /* Compute the number of dest decimal places from dot_pos or assume 0 */
    int dest_frac_digits = 0;
    if (dest_dot_pos >= 0) {
        dest_frac_digits = (int)dest_len - dest_dot_pos - 1;
    }

    /* Build the full integer representation for dest */
    long long result;
    if (dest_frac_digits > 0) {
        /* Scale int_part to include fractional digits */
        result = int_part;
        for (int i = 0; i < dest_frac_digits; i++)
            result *= 10;
        /* Align frac_part to dest precision */
        long long frac_adj = frac_part;
        if (frac_digits < dest_frac_digits) {
            for (int i = 0; i < dest_frac_digits - frac_digits; i++)
                frac_adj *= 10;
        } else if (frac_digits > dest_frac_digits) {
            for (int i = 0; i < frac_digits - dest_frac_digits; i++)
                frac_adj /= 10;
        }
        result += frac_adj;
    } else {
        result = int_part;
    }

    if (dest_dot_pos >= 0) {
        int_to_display_edited(result, dest, dest_len, dest_dot_pos);
    } else {
        int_to_display(result, dest, dest_len);
    }
}

/* ---- INSPECT runtime functions ---- */

/* Find first occurrence of needle in haystack. Returns -1 if not found. */
static int find_substr(const char *haystack, unsigned int hay_len,
                       const char *needle, unsigned int ndl_len) {
    if (ndl_len == 0 || ndl_len > hay_len) return -1;
    for (unsigned int i = 0; i <= hay_len - ndl_len; i++) {
        if (memcmp(haystack + i, needle, ndl_len) == 0) return (int)i;
    }
    return -1;
}

void cobolrt_inspect_tallying(
    const char *data, unsigned int data_len,
    char *tally, unsigned int tally_len,
    unsigned int mode,
    const char *search, unsigned int search_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !tally) return;

    /* Read current tally value */
    long long tally_val = display_to_int(tally, tally_len);

    /* Determine effective range */
    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }
    if (start_pos >= end_pos) return;

    long long count = 0;
    if (mode == 0) {
        /* CHARACTERS */
        count = (long long)(end_pos - start_pos);
    } else if (mode == 1) {
        /* ALL */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                count++;
                i += search_len;
            } else {
                i++;
            }
        }
    } else if (mode == 2) {
        /* LEADING */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                count++;
                i += search_len;
            } else {
                break;
            }
        }
    } else if (mode == 3) {
        /* TRAILING */
        if (!search || search_len == 0) return;
        /* Scan backwards from end_pos */
        unsigned int i = end_pos;
        while (i >= start_pos + search_len) {
            if (memcmp(data + i - search_len, search, search_len) == 0) {
                count++;
                i -= search_len;
            } else {
                break;
            }
        }
    }

    tally_val += count;
    int_to_display(tally_val, tally, tally_len);
}

void cobolrt_inspect_replacing(
    char *data, unsigned int data_len,
    unsigned int mode,
    const char *search, unsigned int search_len,
    const char *replacement, unsigned int replacement_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !replacement) return;

    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }
    if (start_pos >= end_pos) return;

    if (mode == 0) {
        /* CHARACTERS BY replacement */
        char repl_byte = replacement[0];
        for (unsigned int i = start_pos; i < end_pos; i++) {
            data[i] = repl_byte;
        }
    } else if (mode == 1) {
        /* ALL */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
                memcpy(data + i, replacement, copy_len);
                if (replacement_len < search_len) {
                    memset(data + i + replacement_len, ' ', search_len - replacement_len);
                }
                i += search_len;
            } else {
                i++;
            }
        }
    } else if (mode == 2) {
        /* LEADING */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
                memcpy(data + i, replacement, copy_len);
                if (replacement_len < search_len) {
                    memset(data + i + replacement_len, ' ', search_len - replacement_len);
                }
                i += search_len;
            } else {
                break;
            }
        }
    } else if (mode == 3) {
        /* FIRST */
        if (!search || search_len == 0) return;
        int pos = find_substr(data + start_pos, end_pos - start_pos, search, search_len);
        if (pos >= 0) {
            unsigned int abs_pos = start_pos + (unsigned int)pos;
            unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
            memcpy(data + abs_pos, replacement, copy_len);
            if (replacement_len < search_len) {
                memset(data + abs_pos + replacement_len, ' ', search_len - replacement_len);
            }
        }
    } else if (mode == 4) {
        /* TRAILING */
        if (!search || search_len == 0) return;
        unsigned int i = end_pos;
        while (i >= start_pos + search_len) {
            if (memcmp(data + i - search_len, search, search_len) == 0) {
                unsigned int abs_pos = i - search_len;
                unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
                memcpy(data + abs_pos, replacement, copy_len);
                if (replacement_len < search_len) {
                    memset(data + abs_pos + replacement_len, ' ', search_len - replacement_len);
                }
                i -= search_len;
            } else {
                break;
            }
        }
    }
}

void cobolrt_inspect_converting(
    char *data, unsigned int data_len,
    const char *from_chars, unsigned int from_len,
    const char *to_chars, unsigned int to_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !from_chars || !to_chars) return;

    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }

    for (unsigned int i = start_pos; i < end_pos; i++) {
        for (unsigned int j = 0; j < from_len; j++) {
            if (data[i] == from_chars[j]) {
                if (j < to_len) data[i] = to_chars[j];
                break;
            }
        }
    }
}

/* ---- UNSTRING multi-delimiter support ---- */
/* Delimiters are pre-registered via cobolrt_unstring_begin/add_delim,
   then cobolrt_unstring_field uses the registered set. */
static struct {
    const char* ptr;
    unsigned int len;
    unsigned int all;
} __unstring_delims[16];
static unsigned int __unstring_num_delims = 0;

void cobolrt_unstring_begin(unsigned int num_delimiters) {
    __unstring_num_delims = 0;
    (void)num_delimiters;
}

void cobolrt_unstring_add_delim(const char* delim, unsigned int delim_len,
                                unsigned int all_flag) {
    if (__unstring_num_delims < 16) {
        __unstring_delims[__unstring_num_delims].ptr = delim;
        __unstring_delims[__unstring_num_delims].len = delim_len;
        __unstring_delims[__unstring_num_delims].all = all_flag;
        __unstring_num_delims++;
    }
}

/* ---- UNSTRING per-field runtime function ---- */

void cobolrt_unstring_field(
    const char *source, unsigned int source_len,
    char *target, unsigned int target_len,
    char *pointer, unsigned int pointer_len,
    char *tally, unsigned int tally_len,
    char *count_in, unsigned int count_in_len,
    char *delim_in, unsigned int delim_in_len
) {
    if (!source || !target) return;

    /* Read the pointer value (1-based, display-format) */
    unsigned int start_pos = 0;
    if (pointer && pointer_len > 0) {
        long long pos = display_to_int(pointer, pointer_len);
        if (pos < 1) pos = 1;
        start_pos = (unsigned int)(pos - 1);
    }

    if (start_pos >= source_len) {
        /* Overflow: space-fill target */
        memset(target, ' ', target_len);
        return;
    }

    /* Find the earliest-matching delimiter among all registered ones.
       For UNSTRING with OR: try every delimiter, pick the one that
       matches at the earliest position in the remaining source. */
    unsigned int field_end = source_len;
    unsigned int delim_skip = 0;
    int matched_delim_idx = -1;

    for (unsigned int d = 0; d < __unstring_num_delims; d++) {
        const char *dp = __unstring_delims[d].ptr;
        unsigned int dl = __unstring_delims[d].len;
        if (!dp || dl == 0) continue;

        int pos = find_substr(source + start_pos, source_len - start_pos, dp, dl);
        if (pos >= 0) {
            unsigned int abs_pos = start_pos + (unsigned int)pos;
            if (abs_pos < field_end) {
                field_end = abs_pos;
                delim_skip = dl;
                matched_delim_idx = (int)d;

                /* If ALL, skip consecutive delimiters */
                if (__unstring_delims[d].all) {
                    unsigned int next = field_end + dl;
                    delim_skip = dl;
                    while (next + dl <= source_len &&
                           memcmp(source + next, dp, dl) == 0) {
                        next += dl;
                        delim_skip += dl;
                    }
                }
            }
        }
    }

    /* Copy field into target, space-padded */
    unsigned int field_len = field_end - start_pos;
    memset(target, ' ', target_len);
    unsigned int copy_len = field_len < target_len ? field_len : target_len;
    memcpy(target, source + start_pos, copy_len);

    /* Update pointer */
    if (pointer && pointer_len > 0) {
        long long new_pos = (long long)(field_end + delim_skip + 1);
        int_to_display(new_pos, pointer, pointer_len);
    }

    /* Update tally */
    if (tally && tally_len > 0) {
        long long t = display_to_int(tally, tally_len);
        t++;
        int_to_display(t, tally, tally_len);
    }

    /* Update COUNT IN */
    if (count_in && count_in_len > 0) {
        int_to_display((long long)field_len, count_in, count_in_len);
    }

    /* Update DELIMITER IN: store the actual delimiter that was found */
    if (delim_in && delim_in_len > 0) {
        memset(delim_in, ' ', delim_in_len);
        if (matched_delim_idx >= 0 && field_end < source_len) {
            const char *mp = __unstring_delims[matched_delim_idx].ptr;
            unsigned int ml = __unstring_delims[matched_delim_idx].len;
            unsigned int dl = ml < delim_in_len ? ml : delim_in_len;
            memcpy(delim_in, mp, dl);
        }
    }
}

/* ---- COMPUTE result storage ---- */

/*
 * Store a COMPUTE arithmetic result (which may contain a '.' for decimal)
 * into a target display-format field. Auto-detects the source scale from
 * the position of '.' in the source string.
 *
 * For example: src = "25.0000" (from 100/4), dest PIC 9(8):
 *   src_scale detected as 4, src_val = 250000
 *   dest_scale = 0, so scale_diff = -4 → 250000 / 10000 = 25
 *   int_to_display(25, dest, 8) → "00000025"
 */
void cobolrt_store_compute_result(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len, int dest_scale, int dest_dot_pos, int rounded
) {
    /* Use actual string length (null-terminated) rather than estimated size */
    unsigned int actual_len = (unsigned int)strlen(src);
    if (actual_len < src_len) src_len = actual_len;

    /* Auto-detect source scale from '.' position */
    int src_scale = 0;
    int dot_found = 0;
    int is_negative = 0;
    for (unsigned int i = 0; i < src_len; i++) {
        if (src[i] == '.') { dot_found = 1; continue; }
        if (src[i] == '-') { is_negative = 1; continue; }
        if (dot_found && src[i] >= '0' && src[i] <= '9') src_scale++;
    }

    /* Parse the value, skipping '.' and '-' */
    long long src_val = display_to_int_skip(src, src_len);
    if (is_negative && src_val > 0) src_val = -src_val;

    /* Scale adjustment */
    int scale_diff = dest_scale - src_scale;
    long long adjusted = src_val;
    int neg = (adjusted < 0);
    if (neg) adjusted = -adjusted;

    if (scale_diff > 0) {
        for (int i = 0; i < scale_diff; i++)
            adjusted *= 10;
    } else if (scale_diff < 0) {
        if (rounded) {
            for (int i = 0; i < (-scale_diff) - 1; i++)
                adjusted /= 10;
            long long remainder = adjusted % 10;
            adjusted /= 10;
            if (remainder >= 5) adjusted++;
        } else {
            for (int i = 0; i < -scale_diff; i++)
                adjusted /= 10;
        }
    }

    if (neg) adjusted = -adjusted;

    if (dest_dot_pos >= 0) {
        int_to_display_edited(adjusted, dest, dest_len, dest_dot_pos);
    } else {
        int_to_display(adjusted, dest, dest_len);
    }
}

/* ---- COMPUTE/PERFORM support: negate, decimal ops, counter support ---- */

/* Rotating pool of decimal result buffers.
 * Each runtime function that returns a pointer to a decimal string gets
 * its own buffer, preventing aliasing when building complex expression trees
 * like COMPUTE X = A ** 2 + B * C (where pow and mul results must coexist). */
#define DECIMAL_BUF_COUNT 16
#define DECIMAL_BUF_SIZE 128
static char decimal_bufs[DECIMAL_BUF_COUNT][DECIMAL_BUF_SIZE];
static int decimal_buf_idx = 0;

static char* get_decimal_buf(void) {
    char *buf = decimal_bufs[decimal_buf_idx];
    decimal_buf_idx = (decimal_buf_idx + 1) % DECIMAL_BUF_COUNT;
    memset(buf, 0, DECIMAL_BUF_SIZE);
    return buf;
}

/* Negate a display-format numeric value. Returns pointer to rotating buffer. */
char* cobolrt_negate_numeric(const char *data, unsigned int data_len) {
    char *buf = get_decimal_buf();
    if (!data || data_len == 0) return buf;
    unsigned int out_len = data_len + 1;
    if (out_len > DECIMAL_BUF_SIZE) out_len = DECIMAL_BUF_SIZE;
    buf[0] = '-';
    unsigned int copy_len = out_len - 1 < data_len ? out_len - 1 : data_len;
    memcpy(buf + 1, data, copy_len);
    return buf;
}

/* Display-format decimal arithmetic for COMPUTE expressions. */

static long long parse_display_val(const char *data, unsigned int len, int *scale) {
    long long val = 0;
    int neg = 0;
    *scale = 0;
    int past_dot = 0;
    for (unsigned int i = 0; i < len; i++) {
        if (data[i] == '-') { neg = 1; continue; }
        if (data[i] == '.') { past_dot = 1; continue; }
        if (data[i] >= '0' && data[i] <= '9') {
            val = val * 10 + (data[i] - '0');
            if (past_dot) (*scale)++;
        }
    }
    return neg ? -val : val;
}

static char* write_decimal_result(long long val, int scale) {
    char *result_buf = get_decimal_buf();
    int neg = 0;
    if (val < 0) { neg = 1; val = -val; }
    /* Write digits right-to-left */
    char tmp[64];
    int pos = 63;
    tmp[pos] = '\0';
    if (val == 0) { tmp[--pos] = '0'; if (scale > 0) { for (int s = 0; s < scale; s++) tmp[--pos] = '0'; tmp[--pos] = '.'; } }
    else {
        int digit_count = 0;
        long long v = val;
        while (v > 0) { tmp[--pos] = '0' + (v % 10); v /= 10; digit_count++; }
        /* Insert decimal point if needed */
        if (scale > 0 && scale < digit_count) {
            /* Shift digits to make room for dot */
            char tmp2[64];
            int src = pos, dst = 0;
            for (int i = 0; i < digit_count - scale; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst++] = '.';
            for (int i = 0; i < scale; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst] = '\0';
            pos = 0;
            memcpy(tmp, tmp2, dst + 1);
        } else if (scale >= digit_count) {
            /* All digits are fractional: 0.00...digits */
            char tmp2[64];
            int dst = 0;
            tmp2[dst++] = '0';
            tmp2[dst++] = '.';
            for (int i = 0; i < scale - digit_count; i++) tmp2[dst++] = '0';
            int src = pos;
            for (int i = 0; i < digit_count; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst] = '\0';
            pos = 0;
            memcpy(tmp, tmp2, dst + 1);
        }
    }
    int result_start = 0;
    if (neg) { result_buf[result_start++] = '-'; }
    int len = strlen(tmp + pos);
    memcpy(result_buf + result_start, tmp + pos, len);
    result_buf[result_start + len] = '\0';
    return result_buf;
}

char* cobolrt_decimal_add(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    /* Align scales */
    int max_scale = ls > rs ? ls : rs;
    while (ls < max_scale) { lv *= 10; ls++; }
    while (rs < max_scale) { rv *= 10; rs++; }
    return write_decimal_result(lv + rv, max_scale);
}

char* cobolrt_decimal_sub(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    int max_scale = ls > rs ? ls : rs;
    while (ls < max_scale) { lv *= 10; ls++; }
    while (rs < max_scale) { rv *= 10; rs++; }
    return write_decimal_result(lv - rv, max_scale);
}

char* cobolrt_decimal_mul(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    return write_decimal_result(lv * rv, ls + rs);
}

char* cobolrt_decimal_div(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    if (rv == 0) return write_decimal_result(0, 0);
    /* Add extra precision for division */
    int extra = 4;
    for (int i = 0; i < extra; i++) lv *= 10;
    return write_decimal_result(lv / rv, ls - rs + extra);
}

char* cobolrt_decimal_pow(const char *base, unsigned int base_len,
                          const char *exp, unsigned int exp_len,
                          unsigned int result_len) {
    int bs = 0, es = 0;
    long long bv = parse_display_val(base, base_len, &bs);
    long long ev = parse_display_val(exp, exp_len, &es);
    /* Integer exponent only */
    while (es > 0) { ev /= 10; es--; }
    if (ev < 0) return write_decimal_result(0, 0);
    long long result = 1;
    int result_scale = 0;
    for (long long i = 0; i < ev; i++) {
        result *= bv;
        result_scale += bs;
    }
    return write_decimal_result(result, result_scale);
}

/* Convert integer to display-format in a buffer */
void cobolrt_int_to_display(long long val, char *dest) {
    /* Write 8-byte zero-padded display */
    if (val < 0) val = -val;
    for (int i = 7; i >= 0; i--) {
        dest[i] = '0' + (val % 10);
        val /= 10;
    }
}

/*
 * Format a numeric-edited field in-place.
 *
 * `data` already contains the raw numeric digits (with '.' inserted at the
 * correct position by cobolrt_move_numeric / int_to_display_edited).
 * This function walks the PIC string and applies editing:
 *   Z -> zero suppress (replace leading '0' with ' ')
 *   , -> insert comma (but suppress to ' ' if in zero-suppress zone)
 *   . -> keep literal decimal point (already present)
 *   $ -> insert dollar sign
 *   - -> insert '-' for negative, ' ' for positive
 *   + -> insert '+' for positive, '-' for negative
 *   9 -> keep digit as-is
 *
 * The PIC string and the data buffer have a 1:1 positional correspondence
 * (after expanding repetition counts).
 */
void cobolrt_format_numeric_edited(
    char *data, unsigned int data_len,
    const char *pic, unsigned int pic_len
) {
    if (!data || !pic || data_len == 0 || pic_len == 0) return;

    /* Step 1: Expand PIC string into individual characters.
     * E.g. "Z(4)9.99" -> "ZZZZ9.99" */
    char expanded[256];
    unsigned int exp_len = 0;
    for (unsigned int i = 0; i < pic_len && exp_len < sizeof(expanded); ) {
        char ch = pic[i];
        /* Uppercase the character */
        if (ch >= 'a' && ch <= 'z') ch = ch - 32;
        if (i + 1 < pic_len && pic[i + 1] == '(') {
            /* Parse repetition count */
            unsigned int start = i + 2;
            unsigned int end = start;
            while (end < pic_len && pic[end] != ')') end++;
            int count = 0;
            for (unsigned int k = start; k < end; k++) {
                count = count * 10 + (pic[k] - '0');
            }
            for (int k = 0; k < count && exp_len < sizeof(expanded); k++) {
                expanded[exp_len++] = ch;
            }
            i = end + 1;
        } else {
            expanded[exp_len++] = ch;
            i++;
        }
    }

    /* Skip 'S' characters (sign indicator, no storage) and 'V' (implied decimal) */
    char pic_chars[256];
    unsigned int pic_chars_len = 0;
    for (unsigned int i = 0; i < exp_len && pic_chars_len < sizeof(pic_chars); i++) {
        if (expanded[i] != 'S' && expanded[i] != 'V') {
            pic_chars[pic_chars_len++] = expanded[i];
        }
    }

    /* The pic_chars array should now have length == data_len.
     * Walk left-to-right. Track whether we are in the "zero suppress" zone.
     * Zero suppression is active from the start until we hit a significant
     * (non-zero) digit or pass the last Z position. */

    /* First, find the rightmost Z (or * or floating $+-) position.
     * Everything from position 0 to that position is the suppress zone. */
    int last_z_pos = -1;
    for (int i = (int)pic_chars_len - 1; i >= 0; i--) {
        if (pic_chars[i] == 'Z' || pic_chars[i] == '*') {
            last_z_pos = i;
            break;
        }
    }

    /* Determine if the value is zero (all digit positions are '0') */
    int is_all_zero = 1;
    int is_negative = 0;
    for (unsigned int i = 0; i < data_len; i++) {
        if (data[i] >= '1' && data[i] <= '9') {
            is_all_zero = 0;
        }
        /* Check for trailing overpunch negative indicators */
        if (data[i] >= 'p' && data[i] <= 'y') {
            is_negative = 1;
            is_all_zero = 0;
        }
    }

    /* Now walk left-to-right applying the edit */
    int suppressing = 1;  /* start in suppress mode */
    unsigned int d = 0;   /* index into data */

    for (unsigned int p = 0; p < pic_chars_len && d < data_len; p++) {
        char pc = pic_chars[p];
        switch (pc) {
            case '9':
                /* Always show digit, end suppression */
                suppressing = 0;
                d++;
                break;
            case 'Z':
                if (suppressing && data[d] == '0' && (int)p <= last_z_pos) {
                    data[d] = ' ';
                } else {
                    suppressing = 0;
                }
                d++;
                break;
            case '*':
                if (suppressing && data[d] == '0') {
                    data[d] = '*';
                } else {
                    suppressing = 0;
                }
                d++;
                break;
            case '.':
                /* Literal decimal point - already in data */
                d++;
                break;
            case ',':
                /* Comma insertion: if in suppress zone, replace with space */
                if (suppressing) {
                    data[d] = ' ';
                } else {
                    data[d] = ',';
                }
                d++;
                break;
            case '$':
                data[d] = '$';
                d++;
                break;
            case '-':
                if (is_negative) {
                    data[d] = '-';
                } else {
                    data[d] = ' ';
                }
                d++;
                break;
            case '+':
                if (is_negative) {
                    data[d] = '-';
                } else {
                    data[d] = '+';
                }
                d++;
                break;
            case 'B':
                data[d] = ' ';
                d++;
                break;
            case '/':
                data[d] = '/';
                d++;
                break;
            case '0':
                data[d] = '0';
                d++;
                break;
            default:
                d++;
                break;
        }
    }
}

/*
 * De-edit a numeric-edited field: strip editing characters ($, commas, spaces,
 * asterisks, sign characters, B, /, etc.) and produce a raw numeric value in
 * display format, right-justified and zero-padded into dest.
 *
 * src/src_len   : the edited source field (e.g. "$  1,234.56")
 * pic/pic_len   : the PIC string of the source (e.g. "$ZZ,ZZ9.99")
 * dest/dest_len : the target numeric field buffer
 * dest_scale    : number of decimal digits in the target
 * dest_dot_pos  : byte position of literal '.' in dest (-1 if none)
 *
 * Algorithm:
 *  1. Walk source bytes: keep only digits and the decimal point '.'
 *     Also detect sign from '-' characters or CR/DB suffixes.
 *  2. Parse the cleaned string into integer and fractional parts.
 *  3. Scale to dest_scale and write right-justified, zero-padded.
 */
void cobolrt_deedit(
    const char *src, int src_len,
    const char *pic, int pic_len,
    char *dest, int dest_len,
    int dest_scale, int dest_dot_pos
) {
    if (!src || !dest || src_len <= 0 || dest_len <= 0) return;

    /* Step 1: Extract digits and decimal point from the edited source.
     * We walk the source and keep only '0'-'9' and the first '.'.
     * We also detect negative sign from '-', 'CR', 'DB'. */
    int is_negative = 0;
    char cleaned[256];
    int cleaned_len = 0;
    int found_dot = 0;

    for (int i = 0; i < src_len && cleaned_len < (int)sizeof(cleaned) - 1; i++) {
        unsigned char c = (unsigned char)src[i];
        if (c >= '0' && c <= '9') {
            cleaned[cleaned_len++] = (char)c;
        } else if (c == '.' && !found_dot) {
            cleaned[cleaned_len++] = '.';
            found_dot = 1;
        } else if (c == '-') {
            is_negative = 1;
        }
    }
    cleaned[cleaned_len] = '\0';

    /* Check for CR/DB at the end of the source (sign indicators) */
    if (src_len >= 2) {
        char c1 = src[src_len - 2];
        char c2 = src[src_len - 1];
        if ((c1 == 'C' && c2 == 'R') || (c1 == 'D' && c2 == 'B')) {
            is_negative = 1;
        }
    }

    /* Step 2: Parse into integer and fractional parts */
    long long int_part = 0;
    long long frac_part = 0;
    int frac_digits = 0;
    int in_frac = 0;

    for (int i = 0; i < cleaned_len; i++) {
        if (cleaned[i] == '.') {
            in_frac = 1;
            continue;
        }
        if (cleaned[i] >= '0' && cleaned[i] <= '9') {
            if (in_frac) {
                frac_part = frac_part * 10 + (cleaned[i] - '0');
                frac_digits++;
            } else {
                int_part = int_part * 10 + (cleaned[i] - '0');
            }
        }
    }

    /* Step 3: Build the result value scaled to dest_scale */
    long long result = int_part;
    if (dest_scale > 0) {
        for (int i = 0; i < dest_scale; i++) {
            result *= 10;
        }
        /* Adjust frac_part to dest_scale digits */
        long long frac_adj = frac_part;
        if (frac_digits < dest_scale) {
            for (int i = 0; i < dest_scale - frac_digits; i++) {
                frac_adj *= 10;
            }
        } else if (frac_digits > dest_scale) {
            for (int i = 0; i < frac_digits - dest_scale; i++) {
                frac_adj /= 10;
            }
        }
        result += frac_adj;
    }

    /* Step 4: Write into dest, right-justified, zero-padded */
    /* Fill with '0' */
    memset(dest, '0', dest_len);
    if (dest_dot_pos >= 0 && dest_dot_pos < dest_len) {
        dest[dest_dot_pos] = '.';
    }

    /* Write digits right-to-left, skipping dot position */
    unsigned long long val = (unsigned long long)(result < 0 ? -result : result);
    for (int i = dest_len - 1; i >= 0; i--) {
        if (dest_dot_pos >= 0 && i == dest_dot_pos) continue;
        if (val > 0) {
            dest[i] = '0' + (int)(val % 10);
            val /= 10;
        }
    }

    (void)pic;
    (void)pic_len;
    (void)is_negative;
}

/* ---- Class condition runtime functions ---- */

/* IS NUMERIC: returns 1 if every byte is '0'-'9' (0x30-0x39). */
int cobolrt_is_numeric(const char *data, int len) {
    if (!data || len <= 0) return 0;
    for (int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c < '0' || c > '9') return 0;
    }
    return 1;
}

/* IS ALPHABETIC: returns 1 if every byte is 'A'-'Z', 'a'-'z', or space. */
int cobolrt_is_alphabetic(const char *data, int len) {
    if (!data || len <= 0) return 0;
    for (int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c == ' ') continue;
        if (c >= 'A' && c <= 'Z') continue;
        if (c >= 'a' && c <= 'z') continue;
        return 0;
    }
    return 1;
}

/* IS ALPHABETIC-LOWER: returns 1 if every byte is 'a'-'z' or space. */
int cobolrt_is_alphabetic_lower(const char *data, int len) {
    if (!data || len <= 0) return 0;
    for (int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c == ' ') continue;
        if (c >= 'a' && c <= 'z') continue;
        return 0;
    }
    return 1;
}

/* IS ALPHABETIC-UPPER: returns 1 if every byte is 'A'-'Z' or space. */
int cobolrt_is_alphabetic_upper(const char *data, int len) {
    if (!data || len <= 0) return 0;
    for (int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c == ' ') continue;
        if (c >= 'A' && c <= 'Z') continue;
        return 0;
    }
    return 1;
}

/* IS POSITIVE / IS NEGATIVE / IS ZERO sign check.
   Parses a DISPLAY numeric field (ASCII digits, possibly with sign/decimal)
   and checks the sign condition.
   mode: 0 = POSITIVE (value > 0)
         1 = NEGATIVE (value < 0)
         2 = ZERO     (value == 0)
   Returns 1 if condition is true, 0 otherwise. */
int cobolrt_sign_check(const char *data, int len, int scale, int mode) {
    if (!data || len <= 0) return (mode == 2) ? 1 : 0;

    int is_negative = 0;
    long long integer_value = 0;

    for (int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c >= '0' && c <= '9') {
            integer_value = integer_value * 10 + (c - '0');
        } else if (c == '-') {
            is_negative = 1;
        } else if (c == '+' || c == '.' || c == ' ') {
            /* skip sign, decimal point, spaces */
        } else if (c >= 0x70 && c <= 0x79) {
            /* Negative overpunch: p-y represent 0-9 with negative sign */
            integer_value = integer_value * 10 + (c - 0x70);
            is_negative = 1;
        } else if (c >= 0x7B && c <= 0x7B) {
            /* { = negative zero in some EBCDIC-like overpunch */
            is_negative = 1;
        } else if (c == '{') {
            /* positive overpunch for 0 */
            integer_value = integer_value * 10 + 0;
        } else if (c >= 'A' && c <= 'I') {
            /* positive overpunch: A-I = 1-9 */
            integer_value = integer_value * 10 + (c - 'A' + 1);
        } else if (c >= 'J' && c <= 'R') {
            /* negative overpunch: J-R = 1-9 */
            integer_value = integer_value * 10 + (c - 'J' + 1);
            is_negative = 1;
        }
    }

    /* Determine the effective sign */
    /* A value of 0 is neither positive nor negative */
    if (integer_value == 0) {
        return (mode == 2) ? 1 : 0;
    }
    if (is_negative) {
        /* value < 0 */
        return (mode == 1) ? 1 : 0;
    }
    /* value > 0 */
    return (mode == 0) ? 1 : 0;
}

/* ---- Intrinsic function runtime support ---- */

/* Static temp buffer for intrinsic function results.
 * Reused across calls; caller must consume before next intrinsic call. */
static char _intrinsic_temp[4096];

/* FUNCTION UPPER-CASE: convert src to uppercase, return pointer to temp buffer.
 * Result is space-padded to dest_len. */
char* cobolrt_upper_case(const char *src, unsigned int src_len, unsigned int dest_len) {
    unsigned int copy_len = src_len < dest_len ? src_len : dest_len;
    for (unsigned int i = 0; i < copy_len; i++) {
        unsigned char c = (unsigned char)src[i];
        if (c >= 'a' && c <= 'z') {
            _intrinsic_temp[i] = (char)(c - 32);
        } else {
            _intrinsic_temp[i] = (char)c;
        }
    }
    for (unsigned int i = copy_len; i < dest_len; i++) {
        _intrinsic_temp[i] = ' ';
    }
    return _intrinsic_temp;
}

/* FUNCTION LOWER-CASE: convert src to lowercase, return pointer to temp buffer. */
char* cobolrt_lower_case(const char *src, unsigned int src_len, unsigned int dest_len) {
    unsigned int copy_len = src_len < dest_len ? src_len : dest_len;
    for (unsigned int i = 0; i < copy_len; i++) {
        unsigned char c = (unsigned char)src[i];
        if (c >= 'A' && c <= 'Z') {
            _intrinsic_temp[i] = (char)(c + 32);
        } else {
            _intrinsic_temp[i] = (char)c;
        }
    }
    for (unsigned int i = copy_len; i < dest_len; i++) {
        _intrinsic_temp[i] = ' ';
    }
    return _intrinsic_temp;
}

/* FUNCTION REVERSE: reverse the string, return pointer to temp buffer. */
char* cobolrt_reverse(const char *src, unsigned int src_len, unsigned int dest_len) {
    unsigned int copy_len = src_len < dest_len ? src_len : dest_len;
    for (unsigned int i = 0; i < copy_len; i++) {
        _intrinsic_temp[i] = src[copy_len - 1 - i];
    }
    for (unsigned int i = copy_len; i < dest_len; i++) {
        _intrinsic_temp[i] = ' ';
    }
    return _intrinsic_temp;
}

/* FUNCTION TRIM: remove leading and trailing spaces, return pointer to temp buffer.
 * Result is left-justified and space-padded to dest_len. */
char* cobolrt_trim(const char *src, unsigned int src_len, unsigned int dest_len) {
    /* Find start of non-space content */
    unsigned int start = 0;
    while (start < src_len && src[start] == ' ') start++;
    /* Find end of non-space content */
    unsigned int end = src_len;
    while (end > start && src[end - 1] == ' ') end--;
    unsigned int content_len = end - start;
    unsigned int copy_len = content_len < dest_len ? content_len : dest_len;
    memcpy(_intrinsic_temp, src + start, copy_len);
    for (unsigned int i = copy_len; i < dest_len; i++) {
        _intrinsic_temp[i] = ' ';
    }
    return _intrinsic_temp;
}

/* FUNCTION MAX: compare two display-format numeric values, return pointer to the larger.
 * Returns the address of whichever argument is greater. */
char* cobolrt_max_numeric(
    const char *a, unsigned int a_len,
    const char *b, unsigned int b_len
) {
    long long va = display_to_int(a, a_len);
    long long vb = display_to_int(b, b_len);
    if (vb > va) {
        return (char*)b;
    }
    return (char*)a;
}

/* FUNCTION MIN: compare two display-format numeric values, return pointer to the smaller. */
char* cobolrt_min_numeric(
    const char *a, unsigned int a_len,
    const char *b, unsigned int b_len
) {
    long long va = display_to_int(a, a_len);
    long long vb = display_to_int(b, b_len);
    if (vb < va) {
        return (char*)b;
    }
    return (char*)a;
}

/* FUNCTION ORD: return ordinal position of the first character (1-based).
 * In COBOL, ORD('A') returns 66 (ASCII 65 + 1).
 * Returns a display-format string in the intrinsic temp buffer. */
char* cobolrt_ord(const char *src, unsigned int src_len, unsigned int dest_len) {
    int ordinal = 1;
    if (src_len > 0) ordinal = (unsigned char)src[0] + 1;
    int_to_display_ex((long long)ordinal, _intrinsic_temp, dest_len, 0);
    return _intrinsic_temp;
}

/* FUNCTION CHAR: return the character at ordinal position n (1-based).
 * CHAR(66) returns 'A' (ordinal 66 - 1 = ASCII 65). */
char* cobolrt_char(int ordinal) {
    _intrinsic_temp[0] = (char)(ordinal - 1);
    _intrinsic_temp[1] = '\0';
    return _intrinsic_temp;
}

/* FUNCTION MOD: modulo function.
 * MOD(a, b) = a - (b * FUNCTION INTEGER(a / b))
 * Result has the same sign as b. */
char* cobolrt_mod(const char *a, unsigned int a_len,
                  const char *b, unsigned int b_len) {
    long long va = display_to_int(a, a_len);
    long long vb = display_to_int(b, b_len);
    if (vb == 0) {
        /* Division by zero — return 0 */
        memset(_intrinsic_temp, '0', a_len);
        return _intrinsic_temp;
    }
    /* COBOL MOD: a - b * floor(a/b) */
    long long q = va / vb;
    if ((va % vb != 0) && ((va ^ vb) < 0)) q--; /* floor toward negative infinity */
    long long result = va - vb * q;
    int_to_display_ex(result, _intrinsic_temp, a_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION REM: remainder function.
 * REM(a, b) = a - (b * FUNCTION INTEGER-PART(a / b))
 * Result has the same sign as a. */
char* cobolrt_rem(const char *a, unsigned int a_len,
                  const char *b, unsigned int b_len) {
    long long va = display_to_int(a, a_len);
    long long vb = display_to_int(b, b_len);
    if (vb == 0) {
        memset(_intrinsic_temp, '0', a_len);
        return _intrinsic_temp;
    }
    long long result = va % vb; /* C remainder has sign of dividend */
    int_to_display_ex(result, _intrinsic_temp, a_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION NUMVAL: convert alphanumeric string to numeric value.
 * Handles leading/trailing spaces, optional sign, decimal point. */
char* cobolrt_numval(const char *src, unsigned int src_len, unsigned int dest_len) {
    /* Skip leading spaces */
    int i = 0;
    while (i < (int)src_len && src[i] == ' ') i++;
    /* Check for sign */
    int negative = 0;
    if (i < (int)src_len && (src[i] == '-' || src[i] == '+')) {
        if (src[i] == '-') negative = 1;
        i++;
    }
    /* Parse integer and fractional parts */
    long long int_part = 0;
    long long frac_part = 0;
    int frac_digits = 0;
    int saw_decimal = 0;
    while (i < (int)src_len && src[i] != ' ') {
        if (src[i] == '.') {
            saw_decimal = 1;
        } else if (src[i] >= '0' && src[i] <= '9') {
            if (saw_decimal) {
                frac_part = frac_part * 10 + (src[i] - '0');
                frac_digits++;
            } else {
                int_part = int_part * 10 + (src[i] - '0');
            }
        }
        i++;
    }
    /* Check for trailing sign */
    while (i < (int)src_len) {
        if (src[i] == '-') negative = 1;
        else if (src[i] == '+') negative = 0;
        i++;
    }
    /* Combine into scaled integer for display format */
    long long combined = int_part;
    for (int d = 0; d < frac_digits; d++) combined *= 10;
    combined += frac_part;
    if (negative) combined = -combined;
    /* If dest has implicit decimal places, we need to scale accordingly.
     * For simplicity, output as display format. */
    int_to_display_ex(combined, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION ABS: absolute value. */
char* cobolrt_abs(const char *src, unsigned int src_len) {
    long long val = display_to_int(src, src_len);
    if (val < 0) val = -val;
    int_to_display_ex(val, _intrinsic_temp, src_len, 0);
    return _intrinsic_temp;
}

/* FUNCTION SIGN: return +1 for positive, 0 for zero, -1 for negative.
 * Result is a display-format 1-digit value: positive=1 ('1'), zero=0 ('0'),
 * negative=-1 (we use 2 chars with leading sign). Actually COBOL defines
 * SIGN as returning 1, 0, or -1, so we use dest_len for formatting. */
char* cobolrt_sign(const char *src, unsigned int src_len, unsigned int dest_len) {
    long long val = display_to_int(src, src_len);
    long long result;
    if (val > 0) result = 1;
    else if (val < 0) result = -1;
    else result = 0;
    int_to_display_ex(result, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION INTEGER: greatest integer <= argument (floor).
 * For display-format integers this is identity. */
char* cobolrt_integer(const char *src, unsigned int src_len) {
    /* For integer display values, this is a no-op */
    memcpy(_intrinsic_temp, src, src_len);
    return _intrinsic_temp;
}

/* FUNCTION INTEGER-PART: truncate toward zero.
 * For display-format integers this is identity. */
char* cobolrt_integer_part(const char *src, unsigned int src_len) {
    memcpy(_intrinsic_temp, src, src_len);
    return _intrinsic_temp;
}

/* FUNCTION CURRENT-DATE: return 21-char string YYYYMMDDHHMMSSFF+HHMM.
 * Two char for century, two for year, etc. Last 5 are timezone offset. */
char* cobolrt_current_date(void) {
    time_t now = time(NULL);
    struct tm tm_buf;
    localtime_r(&now, &tm_buf);
    snprintf(_intrinsic_temp, 22,
             "%04d%02d%02d%02d%02d%02d00+0000",
             tm_buf.tm_year + 1900,
             tm_buf.tm_mon + 1,
             tm_buf.tm_mday,
             tm_buf.tm_hour,
             tm_buf.tm_min,
             tm_buf.tm_sec);
    /* Compute timezone offset */
    long tz_offset = tm_buf.tm_gmtoff;
    char tz_sign = tz_offset >= 0 ? '+' : '-';
    if (tz_offset < 0) tz_offset = -tz_offset;
    int tz_hours = (int)(tz_offset / 3600);
    int tz_mins = (int)((tz_offset % 3600) / 60);
    snprintf(_intrinsic_temp + 16, 6, "%c%02d%02d", tz_sign, tz_hours, tz_mins);
    return _intrinsic_temp;
}

/* FUNCTION WHEN-COMPILED: compile-time timestamp (placeholder). */
char* cobolrt_when_compiled(void) {
    memcpy(_intrinsic_temp, "20260219120000000000", 21);
    _intrinsic_temp[21] = '\0';
    return _intrinsic_temp;
}

/* FUNCTION SUM: sum of multiple numeric display values.
 * Arguments arrive as pairs of (ptr, len). We pass count separately. */
char* cobolrt_sum(const char **ptrs, const int *lens, int count, unsigned int dest_len) {
    long long total = 0;
    for (int i = 0; i < count; i++) {
        total += display_to_int(ptrs[i], lens[i]);
    }
    int_to_display_ex(total, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION MEAN: arithmetic mean of numeric values. */
char* cobolrt_mean(const char **ptrs, const int *lens, int count, unsigned int dest_len) {
    long long total = 0;
    for (int i = 0; i < count; i++) {
        total += display_to_int(ptrs[i], lens[i]);
    }
    if (count > 0) total /= count;
    int_to_display_ex(total, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION RANGE: max - min of numeric values. */
char* cobolrt_range(const char **ptrs, const int *lens, int count, unsigned int dest_len) {
    if (count == 0) {
        memset(_intrinsic_temp, '0', dest_len);
        return _intrinsic_temp;
    }
    long long min_val = display_to_int(ptrs[0], lens[0]);
    long long max_val = min_val;
    for (int i = 1; i < count; i++) {
        long long v = display_to_int(ptrs[i], lens[i]);
        if (v < min_val) min_val = v;
        if (v > max_val) max_val = v;
    }
    int_to_display_ex(max_val - min_val, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* FUNCTION MEDIAN: middle value of sorted numeric values. */
char* cobolrt_median(const char **ptrs, const int *lens, int count, unsigned int dest_len) {
    if (count == 0) {
        memset(_intrinsic_temp, '0', dest_len);
        return _intrinsic_temp;
    }
    /* Sort values into temp array */
    long long vals[64];
    int n = count < 64 ? count : 64;
    for (int i = 0; i < n; i++) {
        vals[i] = display_to_int(ptrs[i], lens[i]);
    }
    /* Simple insertion sort */
    for (int i = 1; i < n; i++) {
        long long key = vals[i];
        int j = i - 1;
        while (j >= 0 && vals[j] > key) {
            vals[j + 1] = vals[j];
            j--;
        }
        vals[j + 1] = key;
    }
    long long result;
    if (n % 2 == 1) {
        result = vals[n / 2];
    } else {
        result = (vals[n / 2 - 1] + vals[n / 2]) / 2;
    }
    int_to_display_ex(result, _intrinsic_temp, dest_len, 1);
    return _intrinsic_temp;
}

/* ---- SORT USING GIVING implementation ----
 *
 * cobolrt_sort_using_giving reads all records from the input file,
 * sorts them in memory by the specified key(s), and writes the sorted
 * records to the output file.
 *
 * key_info is a string of the form "offset,length,asc;offset,length,asc;..."
 * where asc is 1 for ascending, 0 for descending.
 */

/* Maximum record size and maximum number of records for sort */
#define SORT_MAX_RECORD_SIZE 4096
#define SORT_MAX_RECORDS 100000
#define SORT_MAX_KEYS 16

/* Sort context passed to the qsort comparator via a global (not re-entrant) */
static unsigned int _sort_key_offsets[SORT_MAX_KEYS];
static unsigned int _sort_key_lengths[SORT_MAX_KEYS];
static int          _sort_key_ascending[SORT_MAX_KEYS];
static unsigned int _sort_num_keys = 0;
static unsigned int _sort_record_size = 0;

static int sort_compare(const void *a, const void *b) {
    const char *rec_a = *(const char * const *)a;
    const char *rec_b = *(const char * const *)b;
    for (unsigned int k = 0; k < _sort_num_keys; k++) {
        unsigned int off = _sort_key_offsets[k];
        unsigned int len = _sort_key_lengths[k];
        int asc = _sort_key_ascending[k];
        int cmp = memcmp(rec_a + off, rec_b + off, len);
        if (cmp != 0) {
            return asc ? cmp : -cmp;
        }
    }
    return 0;
}

/* Parse key_info string "off,len,asc;off,len,asc;..." into the global arrays */
static void parse_key_info(const char *key_info, unsigned int key_info_len) {
    _sort_num_keys = 0;
    unsigned int i = 0;
    while (i < key_info_len && _sort_num_keys < SORT_MAX_KEYS) {
        /* Parse offset */
        unsigned int off = 0;
        while (i < key_info_len && key_info[i] >= '0' && key_info[i] <= '9') {
            off = off * 10 + (key_info[i] - '0');
            i++;
        }
        if (i < key_info_len && key_info[i] == ',') i++; /* skip comma */
        /* Parse length */
        unsigned int len = 0;
        while (i < key_info_len && key_info[i] >= '0' && key_info[i] <= '9') {
            len = len * 10 + (key_info[i] - '0');
            i++;
        }
        if (i < key_info_len && key_info[i] == ',') i++; /* skip comma */
        /* Parse ascending flag */
        int asc = 1;
        if (i < key_info_len) {
            asc = (key_info[i] == '1') ? 1 : 0;
            i++;
        }
        if (i < key_info_len && key_info[i] == ';') i++; /* skip semicolon */

        _sort_key_offsets[_sort_num_keys] = off;
        _sort_key_lengths[_sort_num_keys] = len;
        _sort_key_ascending[_sort_num_keys] = asc;
        _sort_num_keys++;
    }
}

void cobolrt_sort_using_giving(
    const char *input_filename, unsigned int input_filename_len,
    const char *output_filename, unsigned int output_filename_len,
    unsigned int record_size,
    unsigned int num_keys,
    const char *key_info, unsigned int key_info_len
) {
    (void)num_keys; /* We parse actual count from key_info */

    /* Build null-terminated filenames */
    char in_fname[1024];
    char out_fname[1024];
    unsigned int in_len = input_filename_len < sizeof(in_fname) - 1
        ? input_filename_len : (unsigned int)(sizeof(in_fname) - 1);
    memcpy(in_fname, input_filename, in_len);
    in_fname[in_len] = '\0';
    unsigned int out_len = output_filename_len < sizeof(out_fname) - 1
        ? output_filename_len : (unsigned int)(sizeof(out_fname) - 1);
    memcpy(out_fname, output_filename, out_len);
    out_fname[out_len] = '\0';

    /* Parse key info */
    parse_key_info(key_info, key_info_len);
    _sort_record_size = record_size;

    /* If no keys were parsed, use the whole record as one ascending key */
    if (_sort_num_keys == 0) {
        _sort_key_offsets[0] = 0;
        _sort_key_lengths[0] = record_size;
        _sort_key_ascending[0] = 1;
        _sort_num_keys = 1;
    }

    /* Read all records from input file */
    FILE *fin = fopen(in_fname, "r");
    if (!fin) return;

    char **records = (char **)malloc(SORT_MAX_RECORDS * sizeof(char *));
    if (!records) { fclose(fin); return; }
    unsigned int count = 0;
    char line[SORT_MAX_RECORD_SIZE + 2]; /* +2 for newline and null */

    while (fgets(line, sizeof(line), fin) != NULL && count < SORT_MAX_RECORDS) {
        /* Remove trailing newline/carriage return */
        size_t len = strlen(line);
        if (len > 0 && line[len - 1] == '\n') { line[--len] = '\0'; }
        if (len > 0 && line[len - 1] == '\r') { line[--len] = '\0'; }

        /* Allocate a fixed-size record buffer, space-padded */
        char *rec = (char *)malloc(record_size);
        if (!rec) break;
        memset(rec, ' ', record_size);
        unsigned int copy_len = (unsigned int)len < record_size ? (unsigned int)len : record_size;
        memcpy(rec, line, copy_len);

        records[count++] = rec;
    }
    fclose(fin);

    /* Sort the records */
    if (count > 0) {
        qsort(records, count, sizeof(char *), sort_compare);
    }

    /* Write sorted records to output file */
    FILE *fout = fopen(out_fname, "w");
    if (fout) {
        for (unsigned int i = 0; i < count; i++) {
            /* Trim trailing spaces for output */
            int end = (int)record_size - 1;
            while (end >= 0 && records[i][end] == ' ') end--;
            fwrite(records[i], 1, (size_t)(end + 1), fout);
            fputc('\n', fout);
        }
        fclose(fout);
    }

    /* Free records */
    for (unsigned int i = 0; i < count; i++) {
        free(records[i]);
    }
    free(records);
}
"#;

/// cobolc -- The World's Best Open-Source COBOL Compiler
#[derive(Parser, Debug)]
#[command(name = "cobolc", version, about)]
struct Cli {
    #[command(subcommand)]
    command: Option<Command>,

    /// Input COBOL source file(s)
    input: Vec<PathBuf>,

    /// Output file path
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Codegen backend to use
    #[arg(long, default_value = "cranelift", value_parser = ["llvm", "cranelift"])]
    backend: String,

    /// COBOL dialect
    #[arg(long, default_value = "cobol85", value_parser = ["cobol85", "ibm", "microfocus", "gnucobol"])]
    dialect: String,

    /// What to emit
    #[arg(long, default_value = "exe", value_parser = ["exe", "obj", "llvm-ir", "mir", "hir", "ast", "tokens", "preprocessed"])]
    emit: String,

    /// Optimization level
    #[arg(short = 'O', long = "opt-level", default_value = "0", value_parser = ["0", "1", "2", "3", "s"])]
    opt_level: String,

    /// Source format
    #[arg(long, default_value = "fixed", value_parser = ["fixed", "free"])]
    format: String,

    /// Copybook include directories
    #[arg(short = 'I', long = "include")]
    include_dirs: Vec<PathBuf>,

    /// Enable verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Dump internal representations for debugging
    #[arg(long)]
    dump: bool,
}

#[derive(clap::Subcommand, Debug)]
enum Command {
    /// Start the Language Server Protocol server (for IDE integration)
    Lsp,
}

fn main() {
    let cli = Cli::parse();

    // Handle subcommands
    if let Some(Command::Lsp) = cli.command {
        let rt = tokio::runtime::Runtime::new().expect("failed to create tokio runtime");
        rt.block_on(cobol_lsp::run_server());
        return;
    }

    if cli.input.is_empty() {
        eprintln!("error: no input files specified");
        eprintln!("usage: cobolc <FILE>... [OPTIONS]");
        eprintln!("       cobolc lsp");
        std::process::exit(1);
    }

    if cli.verbose {
        eprintln!("cobolc v{}", env!("CARGO_PKG_VERSION"));
        eprintln!("Backend: {}", cli.backend);
        eprintln!("Dialect: {}", cli.dialect);
        eprintln!("Format: {}", cli.format);
        eprintln!("Optimization: O{}", cli.opt_level);
    }

    // Set up the compilation database
    let mut db = cobol_db::SimpleDatabase::new();

    // Add copybook directories
    for dir in &cli.include_dirs {
        db.vfs_mut().add_copybook_dir(dir.clone());
    }

    // Auto-add source file directories and their copybooks/ subdirectories
    for input_path in &cli.input {
        if let Some(parent) = std::path::Path::new(input_path).parent() {
            let parent = if parent.as_os_str().is_empty() {
                std::path::PathBuf::from(".")
            } else {
                parent.to_path_buf()
            };
            db.vfs_mut().add_copybook_dir(parent.clone());
            let copybooks_dir = parent.join("copybooks");
            if copybooks_dir.is_dir() {
                db.vfs_mut().add_copybook_dir(copybooks_dir);
            }
        }
    }

    // Determine source format
    let source_format = match cli.format.as_str() {
        "free" => cobol_lexer::SourceFormat::Free,
        _ => cobol_lexer::SourceFormat::Fixed,
    };

    // For exe/obj mode, accumulate object files across all inputs,
    // then link once at the end.
    let mut obj_files: Vec<PathBuf> = Vec::new();

    // Process each input file
    for (input_idx, input_path) in cli.input.iter().enumerate() {
        // Load the source file
        let file_id = match db.vfs_mut().load_file(input_path) {
            Ok(id) => id,
            Err(e) => {
                eprintln!("error: {}", e);
                std::process::exit(1);
            }
        };

        // Get the source text
        let source = match db.vfs().file_content(file_id) {
            Some(s) => s.to_string(),
            None => {
                eprintln!("error: could not read file {:?}", input_path);
                std::process::exit(1);
            }
        };

        use cobol_db::InputDatabase;
        db.set_file_text(file_id, source.clone());
        db.set_source_format(file_id, source_format);

        // Run the preprocessor to expand COPY/REPLACE directives
        let pp_result = cobol_pp::preprocess(&source, file_id, db.vfs());
        let pp_text = pp_result.text.clone();

        if !pp_result.errors.is_empty() {
            for err in &pp_result.errors {
                eprintln!("warning: {}", err);
            }
        }

        // Run the pipeline based on --emit
        match cli.emit.as_str() {
            "preprocessed" => {
                print!("{}", pp_text);
            }
            "tokens" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                for token in &tokens {
                    if cli.dump {
                        println!("{:?}", token);
                    } else {
                        println!("{:?}: {:?}", token.kind, token.text);
                    }
                }
            }
            "ast" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                if cli.dump {
                    println!("{:#?}", parse_result.green);
                }
                for err in &parse_result.errors {
                    eprintln!("error: {}", err);
                }
            }
            "hir" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                let syntax = parse_result.syntax();
                let ast =
                    cobol_ast::SourceFile::cast(syntax).expect("root node should be SOURCE_FILE");
                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner, file_id);
                if cli.dump {
                    println!("{:#?}", hir);
                }
                for diag in &hir.diagnostics {
                    eprintln!("{:?}: {}", diag.severity, diag.message);
                }
            }
            "mir" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                let syntax = parse_result.syntax();
                let ast =
                    cobol_ast::SourceFile::cast(syntax).expect("root node should be SOURCE_FILE");
                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner, file_id);
                let mir = cobol_mir::lower(&hir, &interner);
                if cli.dump {
                    println!("{:#?}", mir);
                } else {
                    println!(
                        "MIR module: {} ({} functions, {} globals)",
                        mir.name,
                        mir.functions.len(),
                        mir.globals.len()
                    );
                }
            }
            "obj" | "exe" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                if !parse_result.errors.is_empty() && !cli.verbose {
                    eprintln!(
                        "warning: {} parse error(s); continuing anyway",
                        parse_result.errors.len()
                    );
                }

                let syntax = parse_result.syntax();
                let ast =
                    cobol_ast::SourceFile::cast(syntax).expect("root node should be SOURCE_FILE");

                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner, file_id);
                for diag in &hir.diagnostics {
                    if diag.severity == cobol_hir::DiagnosticSeverity::Error {
                        eprintln!("error: {}", diag.message);
                    }
                }

                // First input file is the main program; subsequent files are subprograms
                let is_main = input_idx == 0;
                let mut mir = cobol_mir::lower_with_options(&hir, &interner, is_main);

                if !mir.errors.is_empty() {
                    for err in &mir.errors {
                        eprintln!("error: {}", err);
                    }
                    std::process::exit(1);
                }

                // Run MIR optimization passes.
                let mir_opt_level = match cli.opt_level.as_str() {
                    "0" => cobol_mir::passes::OptLevel::None,
                    "1" => cobol_mir::passes::OptLevel::Basic,
                    _ => cobol_mir::passes::OptLevel::Full,
                };
                cobol_mir::passes::optimize(&mut mir, mir_opt_level);

                if cli.verbose {
                    eprintln!(
                        "MIR: {} functions, {} globals",
                        mir.functions.len(),
                        mir.globals.len()
                    );
                }

                // Determine object file path
                let stem = input_path
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("output");
                let obj_path = if cli.emit == "obj" && cli.input.len() == 1 {
                    cli.output
                        .clone()
                        .unwrap_or_else(|| input_path.with_extension("o"))
                } else {
                    // For exe or multi-file obj, use temp .o files
                    std::env::temp_dir().join(format!("{}_{}.o", stem, std::process::id()))
                };

                // Codegen
                use cobol_codegen_llvm::CodegenBackend;
                let backend: Box<dyn CodegenBackend> = match cli.backend.as_str() {
                    "cranelift" => Box::new(cobol_codegen_cranelift::CraneliftBackend::new()),
                    "llvm" => Box::new(cobol_codegen_llvm::LlvmBackend::new(
                        cobol_codegen_llvm::OptLevel::O2,
                    )),
                    other => {
                        eprintln!(
                            "error: unknown backend '{}', use 'cranelift' or 'llvm'",
                            other
                        );
                        std::process::exit(1);
                    }
                };

                if cli.verbose {
                    eprintln!("codegen backend: {}", backend.name());
                }

                if let Err(e) = backend.compile(&mir, &obj_path) {
                    eprintln!("error: codegen failed: {}", e);
                    std::process::exit(1);
                }

                if cli.verbose {
                    eprintln!("wrote object file: {}", obj_path.display());
                }

                obj_files.push(obj_path);
            }
            _ => {
                eprintln!("error: unknown --emit value: {}", cli.emit);
                eprintln!(
                    "hint: use --emit=tokens, --emit=ast, --emit=hir, --emit=mir, --emit=obj, or --emit=exe"
                );
                std::process::exit(1);
            }
        }
    }

    // After all files are compiled, link if exe mode
    if cli.emit == "exe" && !obj_files.is_empty() {
        let first_input = &cli.input[0];
        let exe_path = cli.output.clone().unwrap_or_else(|| {
            if cfg!(windows) {
                first_input.with_extension("exe")
            } else {
                first_input.with_extension("")
            }
        });

        // Write the C runtime shim to a temp file
        let runtime_c = std::env::temp_dir().join(format!("cobolrt_shim_{}.c", std::process::id()));
        std::fs::write(&runtime_c, RUNTIME_SHIM_C).unwrap_or_else(|e| {
            eprintln!("error: failed to write runtime shim: {}", e);
            std::process::exit(1);
        });

        // Link all object files + runtime → executable
        let mut cmd = std::process::Command::new("cc");
        for obj in &obj_files {
            cmd.arg(obj);
        }
        cmd.arg(&runtime_c).arg("-o").arg(&exe_path).arg("-lc");

        let status = cmd.status();

        match status {
            Ok(s) if s.success() => {
                if cli.verbose {
                    eprintln!("linked executable: {}", exe_path.display());
                }
            }
            Ok(s) => {
                eprintln!("error: linker exited with status {}", s);
                std::process::exit(1);
            }
            Err(e) => {
                eprintln!("error: failed to run linker: {}", e);
                eprintln!("hint: ensure a C compiler (cc) is installed");
                std::process::exit(1);
            }
        }

        // Clean up temp files
        for obj in &obj_files {
            let _ = std::fs::remove_file(obj);
        }
        let _ = std::fs::remove_file(&runtime_c);
    }

    if cli.verbose {
        eprintln!("compilation complete");
    }
}
