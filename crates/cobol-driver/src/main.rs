use clap::Parser;
use cobol_ast::AstNode;
use std::path::PathBuf;

/// Minimal C runtime shim for Phase 1.
///
/// This provides the runtime functions that generated code calls at link time.
/// For Phase 1, we only need: cobolrt_display_line, cobolrt_display,
/// cobolrt_stop_run, and a `main` entry point is generated by Cranelift.
const RUNTIME_SHIM_C: &str = r#"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void cobolrt_display_line(const char *data, unsigned int len) {
    if (data && len > 0) {
        fwrite(data, 1, len, stdout);
    }
    fputc('\n', stdout);
    fflush(stdout);
}

void cobolrt_display(const char *data, unsigned int len) {
    if (data && len > 0) {
        fwrite(data, 1, len, stdout);
    }
    fflush(stdout);
}

void cobolrt_stop_run(int status) {
    exit(status);
}

void cobolrt_accept(char *buffer, unsigned int buffer_len) {
    if (buffer && buffer_len > 0) {
        memset(buffer, ' ', buffer_len);
        if (fgets(buffer, buffer_len + 1, stdin) != NULL) {
            /* Remove trailing newline */
            size_t len = strlen(buffer);
            if (len > 0 && buffer[len-1] == '\n') {
                buffer[len-1] = ' ';
            }
            /* Pad with spaces up to buffer_len */
            for (size_t i = strlen(buffer); i < buffer_len; i++) {
                buffer[i] = ' ';
            }
        }
    }
}

/* ACCEPT FROM DATE: writes YYMMDD into buffer */
void cobolrt_accept_date(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[7];
    snprintf(tmp, sizeof(tmp), "%02d%02d%02d",
             t->tm_year % 100, t->tm_mon + 1, t->tm_mday);
    unsigned int copy_len = 6 < buffer_len ? 6 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM DAY: writes YYDDD into buffer */
void cobolrt_accept_day(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[6];
    snprintf(tmp, sizeof(tmp), "%02d%03d",
             t->tm_year % 100, t->tm_yday + 1);
    unsigned int copy_len = 5 < buffer_len ? 5 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM TIME: writes HHMMSSCC into buffer (CC = centiseconds) */
void cobolrt_accept_time(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char tmp[9];
    snprintf(tmp, sizeof(tmp), "%02d%02d%02d00",
             t->tm_hour, t->tm_min, t->tm_sec);
    unsigned int copy_len = 8 < buffer_len ? 8 : buffer_len;
    memcpy(buffer, tmp, copy_len);
    if (buffer_len > copy_len) memset(buffer + copy_len, ' ', buffer_len - copy_len);
}

/* ACCEPT FROM DAY-OF-WEEK: writes 1-7 (1=Monday) into buffer */
void cobolrt_accept_day_of_week(char *buffer, unsigned int buffer_len) {
    if (!buffer || buffer_len == 0) return;
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    /* tm_wday: 0=Sunday, 1=Monday, ..., 6=Saturday
       COBOL: 1=Monday, ..., 7=Sunday */
    int dow = t->tm_wday == 0 ? 7 : t->tm_wday;
    char tmp[2];
    snprintf(tmp, sizeof(tmp), "%d", dow);
    buffer[0] = tmp[0];
    if (buffer_len > 1) memset(buffer + 1, ' ', buffer_len - 1);
}

void cobolrt_move_alphanumeric(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len
) {
    if (src_len >= dest_len) {
        memcpy(dest, src, dest_len);
    } else {
        memcpy(dest, src, src_len);
        memset(dest + src_len, ' ', dest_len - src_len);
    }
}

void cobolrt_initialize_alphanumeric(char *data, unsigned int len) {
    memset(data, ' ', len);
}

void cobolrt_initialize_numeric(char *data, unsigned int len) {
    memset(data, '0', len);
}

/* Convert display-format numeric (ASCII digits) to a 64-bit integer.
 * Supports signed fields using trailing overpunch encoding:
 *   Positive: last byte '0'-'9' (0x30-0x39) or '{','A'-'I' (0x7B,0x41-0x49)
 *   Negative: last byte 'p'-'y' (0x70-0x79) â€” digit + 0x40
 * For unsigned fields, all bytes are plain digits. */
static long long display_to_int(const char *data, unsigned int len) {
    long long result = 0;
    int negative = 0;
    for (unsigned int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c >= '0' && c <= '9') {
            result = result * 10 + (c - '0');
        } else if (c >= 'p' && c <= 'y') {
            /* Trailing overpunch: negative sign, digit = c - 0x40 */
            result = result * 10 + (c - 'p');
            negative = 1;
        } else if (c == '{') {
            /* Positive overpunch for 0 (some conventions) */
            result = result * 10 + 0;
        } else if (c >= 'A' && c <= 'I') {
            /* Positive overpunch for 1-9 (some conventions) */
            result = result * 10 + (c - 'A' + 1);
        }
    }
    return negative ? -result : result;
}

/* Write a 64-bit integer into display format (ASCII digits, right-justified, zero-padded).
 * Negative values are encoded using trailing overpunch: last digit + 0x40. */
static void int_to_display(long long value, char *data, unsigned int len) {
    int negative = (value < 0);
    if (value < 0) value = -value;
    memset(data, '0', len);
    for (int i = (int)len - 1; i >= 0 && value > 0; i--) {
        data[i] = '0' + (char)(value % 10);
        value /= 10;
    }
    if (negative && len > 0) {
        /* Apply trailing overpunch to the last byte: add 0x40 */
        data[len - 1] = (char)(data[len - 1] + 0x40);
    }
}

void cobolrt_add_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a + b;
    int_to_display(result, dest, dest_len);
}

void cobolrt_subtract_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a - b;
    int_to_display(result, dest, dest_len);
}

void cobolrt_multiply_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = a * b;
    int_to_display(result, dest, dest_len);
}

void cobolrt_divide_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len,
    char *dest, unsigned int dest_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    long long result = (b != 0) ? (a / b) : 0;
    int_to_display(result, dest, dest_len);
}

int cobolrt_compare_numeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len
) {
    long long a = display_to_int(src1, src1_len);
    long long b = display_to_int(src2, src2_len);
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}

/* Convert display-format bytes to a 64-bit integer (public runtime function). */
long long cobolrt_display_to_int(const char *data, unsigned int len) {
    return display_to_int(data, len);
}

/* Read digits from a display buffer, skipping non-digit chars (e.g. '.').
 * Handles trailing overpunch for signed fields. */
static long long display_to_int_skip(const char *data, unsigned int len) {
    long long result = 0;
    int negative = 0;
    for (unsigned int i = 0; i < len; i++) {
        unsigned char c = (unsigned char)data[i];
        if (c >= '0' && c <= '9') {
            result = result * 10 + (c - '0');
        } else if (c >= 'p' && c <= 'y') {
            result = result * 10 + (c - 'p');
            negative = 1;
        } else if (c == '{') {
            result = result * 10 + 0;
        } else if (c >= 'A' && c <= 'I') {
            result = result * 10 + (c - 'A' + 1);
        }
        /* skip '.', spaces, etc. */
    }
    return negative ? -result : result;
}

/* Write digits to a display buffer, inserting '.' at dot_pos if >= 0. */
static void int_to_display_edited(long long value, char *data, unsigned int len,
                                   int dot_pos) {
    if (value < 0) value = -value;
    /* Count digit positions (all except the dot) */
    unsigned int num_digits = (dot_pos >= 0) ? len - 1 : len;
    /* Fill with zeros first */
    memset(data, '0', len);
    if (dot_pos >= 0 && dot_pos < (int)len) {
        data[dot_pos] = '.';
    }
    /* Write digits right-to-left, skipping the dot position */
    for (int i = (int)len - 1; i >= 0 && (value > 0 || num_digits > 0); i--) {
        if (dot_pos >= 0 && i == dot_pos) continue;
        if (value > 0) {
            data[i] = '0' + (char)(value % 10);
            value /= 10;
        } else {
            data[i] = '0';
        }
        num_digits--;
    }
}

void cobolrt_divide_scaled(
    const char *src1, unsigned int src1_len, int src1_scale,
    const char *src2, unsigned int src2_len, int src2_scale,
    char *dest, unsigned int dest_len, int dest_scale,
    int dest_dot_pos, int rounded
) {
    long long dividend = display_to_int_skip(src1, src1_len);
    long long divisor = display_to_int_skip(src2, src2_len);

    if (divisor == 0) {
        /* Division by zero: fill result with zeros */
        int_to_display_edited(0, dest, dest_len, dest_dot_pos);
        return;
    }

    /*
     * Scale adjustment:
     * dividend represents a value * 10^src1_scale
     * divisor represents a value * 10^src2_scale
     * result should represent value * 10^dest_scale
     *
     * result_raw = dividend / divisor (in integer terms)
     * But we need: result = (dividend / 10^src1_scale) / (divisor / 10^src2_scale) * 10^dest_scale
     * => result = dividend * 10^(dest_scale - src1_scale + src2_scale) / divisor
     */
    int scale_adjust = dest_scale - src1_scale + src2_scale;

    long long adjusted_dividend = dividend;
    if (scale_adjust > 0) {
        for (int i = 0; i < scale_adjust; i++)
            adjusted_dividend *= 10;
    } else if (scale_adjust < 0) {
        for (int i = 0; i < -scale_adjust; i++)
            adjusted_dividend /= 10;
    }

    long long result;
    if (rounded) {
        /* For rounding, compute one extra decimal place */
        long long extended = adjusted_dividend * 10 / divisor;
        result = extended / 10;
        if ((extended % 10) >= 5) result++;
    } else {
        result = adjusted_dividend / divisor;
    }

    int_to_display_edited(result, dest, dest_len, dest_dot_pos);
}

int cobolrt_compare_alphanumeric(
    const char *src1, unsigned int src1_len,
    const char *src2, unsigned int src2_len
) {
    unsigned int min_len = src1_len < src2_len ? src1_len : src2_len;
    for (unsigned int i = 0; i < min_len; i++) {
        unsigned char a = (unsigned char)src1[i];
        unsigned char b = (unsigned char)src2[i];
        if (a < b) return -1;
        if (a > b) return 1;
    }
    /* If one is shorter, trailing spaces are implied */
    if (src1_len < src2_len) {
        for (unsigned int i = src1_len; i < src2_len; i++) {
            unsigned char b = (unsigned char)src2[i];
            if (' ' < b) return -1;
            if (' ' > b) return 1;
        }
    } else if (src2_len < src1_len) {
        for (unsigned int i = src2_len; i < src1_len; i++) {
            unsigned char a = (unsigned char)src1[i];
            if (a < ' ') return -1;
            if (a > ' ') return 1;
        }
    }
    return 0;
}

/* ---- File I/O ---- */

/* Simple file handle table: up to 64 open files */
#define MAX_OPEN_FILES 64
static FILE *open_files[MAX_OPEN_FILES] = {0};

int cobolrt_file_open(const char *filename, unsigned int filename_len, int mode) {
    /* Build null-terminated filename */
    char fname[1024];
    unsigned int copy_len = filename_len < sizeof(fname) - 1 ? filename_len : sizeof(fname) - 1;
    memcpy(fname, filename, copy_len);
    fname[copy_len] = '\0';

    const char *fmode;
    switch (mode) {
        case 0: fmode = "r";  break; /* INPUT */
        case 1: fmode = "w";  break; /* OUTPUT */
        case 2: fmode = "r+"; break; /* I-O */
        case 3: fmode = "a";  break; /* EXTEND */
        default: fmode = "r"; break;
    }

    FILE *fp = fopen(fname, fmode);
    if (!fp) return -1;

    /* Find a free slot */
    for (int i = 0; i < MAX_OPEN_FILES; i++) {
        if (open_files[i] == NULL) {
            open_files[i] = fp;
            return i;
        }
    }
    /* No free slot */
    fclose(fp);
    return -1;
}

void cobolrt_file_close(int handle) {
    if (handle >= 0 && handle < MAX_OPEN_FILES && open_files[handle]) {
        fclose(open_files[handle]);
        open_files[handle] = NULL;
    }
}

void cobolrt_file_write_line(int handle, const char *data, unsigned int data_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return;
    /* Write data, trimming trailing spaces, then add newline */
    int end = (int)data_len - 1;
    while (end >= 0 && data[end] == ' ') end--;
    fwrite(data, 1, (size_t)(end + 1), open_files[handle]);
    fputc('\n', open_files[handle]);
    fflush(open_files[handle]);
}

int cobolrt_file_read_line(int handle, char *buffer, unsigned int buffer_len) {
    if (handle < 0 || handle >= MAX_OPEN_FILES || !open_files[handle]) return 1;
    /* Space-fill buffer first */
    memset(buffer, ' ', buffer_len);
    char line[4096];
    if (fgets(line, sizeof(line), open_files[handle]) == NULL) {
        return 1; /* EOF */
    }
    /* Remove trailing newline */
    size_t len = strlen(line);
    if (len > 0 && line[len - 1] == '\n') {
        line[len - 1] = '\0';
        len--;
    }
    if (len > 0 && line[len - 1] == '\r') {
        line[len - 1] = '\0';
        len--;
    }
    /* Copy into buffer, space-pad remainder */
    unsigned int copy_len = len < buffer_len ? (unsigned int)len : buffer_len;
    memcpy(buffer, line, copy_len);
    return 0; /* OK */
}

void cobolrt_string_append(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len,
    char *ptr, unsigned int ptr_len
) {
    /* Read the pointer value (1-based, display-format numeric) */
    long long pos = display_to_int(ptr, ptr_len);

    /* COBOL STRING uses 1-based positioning */
    unsigned int dest_pos = (unsigned int)(pos - 1);

    /* Copy source bytes into destination starting at dest_pos */
    unsigned int copied = 0;
    for (unsigned int i = 0; i < src_len && dest_pos + copied < dest_len; i++) {
        dest[dest_pos + copied] = src[i];
        copied++;
    }

    /* Update the pointer value */
    long long new_pos = pos + (long long)copied;
    int_to_display(new_pos, ptr, ptr_len);
}

/* ---- MOVE type conversion functions ---- */

/*
 * Numeric-to-numeric MOVE with scale alignment.
 * src/dest are display-format buffers. src_scale/dest_scale indicate digits
 * after the implied decimal point. dest_dot_pos indicates the position of a
 * literal '.' in an edited PIC (e.g. PIC 9(5).99), -1 if none.
 *
 * For example: MOVE WS-A PIC 9(5)V99 TO WS-B PIC 9(3)V9(4)
 *   src has 7 digits, scale=2 (2 after V)
 *   dest has 7 digits, scale=4 (4 after V)
 *   We align on the decimal point, pad with zeros, truncate as needed.
 */
void cobolrt_move_numeric(
    const char *src, unsigned int src_len, int src_scale, int src_dot_pos,
    char *dest, unsigned int dest_len, int dest_scale, int dest_dot_pos,
    int rounded
) {
    /* Extract the integer value from source, skipping any '.' */
    long long src_val = display_to_int_skip(src, src_len);

    /* Adjust scale: if dest has more decimal places, multiply; fewer, divide */
    int scale_diff = dest_scale - src_scale;
    long long adjusted = src_val;
    if (scale_diff > 0) {
        for (int i = 0; i < scale_diff; i++)
            adjusted *= 10;
    } else if (scale_diff < 0) {
        if (rounded && scale_diff == -1) {
            /* Round: check the last digit before truncating */
            long long remainder = adjusted % 10;
            adjusted /= 10;
            if (remainder >= 5) adjusted++;
        } else if (rounded && scale_diff < -1) {
            /* Round: compute one extra digit, check, then truncate */
            for (int i = 0; i < (-scale_diff) - 1; i++)
                adjusted /= 10;
            long long remainder = adjusted % 10;
            adjusted /= 10;
            if (remainder >= 5) adjusted++;
        } else {
            for (int i = 0; i < -scale_diff; i++)
                adjusted /= 10;
        }
    }

    /* Write the result into the destination */
    if (dest_dot_pos >= 0) {
        int_to_display_edited(adjusted, dest, dest_len, dest_dot_pos);
    } else {
        int_to_display(adjusted, dest, dest_len);
    }
}

/*
 * Numeric-to-alphanumeric MOVE.
 * Converts the numeric display value to a left-justified string.
 * Leading zeros are preserved (COBOL standard for MOVE numeric TO alpha).
 * The result is left-justified and space-padded on the right.
 */
void cobolrt_move_num_to_alpha(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len
) {
    /* Copy the display representation, left-justified */
    unsigned int copy_len = src_len < dest_len ? src_len : dest_len;
    memcpy(dest, src, copy_len);
    /* Space-pad the remainder */
    if (copy_len < dest_len) {
        memset(dest + copy_len, ' ', dest_len - copy_len);
    }
}

/*
 * Alphanumeric-to-numeric MOVE.
 * Parses the alphanumeric field as a number.
 * Non-numeric characters result in those positions being treated as zero.
 * Result is right-justified, zero-padded in the dest.
 */
void cobolrt_move_alpha_to_num(
    const char *src, unsigned int src_len,
    char *dest, unsigned int dest_len, int dest_dot_pos
) {
    /* Parse the source as a numeric value, ignoring non-digits except '.' */
    long long int_part = 0;
    long long frac_part = 0;
    int frac_digits = 0;
    int in_frac = 0;

    for (unsigned int i = 0; i < src_len; i++) {
        char c = src[i];
        if (c == '.') {
            in_frac = 1;
            continue;
        }
        if (c >= '0' && c <= '9') {
            if (in_frac) {
                frac_part = frac_part * 10 + (c - '0');
                frac_digits++;
            } else {
                int_part = int_part * 10 + (c - '0');
            }
        }
        /* Non-numeric chars (spaces, letters) are ignored */
    }

    /* Compute the number of dest decimal places from dot_pos or assume 0 */
    int dest_frac_digits = 0;
    if (dest_dot_pos >= 0) {
        dest_frac_digits = (int)dest_len - dest_dot_pos - 1;
    }

    /* Build the full integer representation for dest */
    long long result;
    if (dest_frac_digits > 0) {
        /* Scale int_part to include fractional digits */
        result = int_part;
        for (int i = 0; i < dest_frac_digits; i++)
            result *= 10;
        /* Align frac_part to dest precision */
        long long frac_adj = frac_part;
        if (frac_digits < dest_frac_digits) {
            for (int i = 0; i < dest_frac_digits - frac_digits; i++)
                frac_adj *= 10;
        } else if (frac_digits > dest_frac_digits) {
            for (int i = 0; i < frac_digits - dest_frac_digits; i++)
                frac_adj /= 10;
        }
        result += frac_adj;
    } else {
        result = int_part;
    }

    if (dest_dot_pos >= 0) {
        int_to_display_edited(result, dest, dest_len, dest_dot_pos);
    } else {
        int_to_display(result, dest, dest_len);
    }
}

/* ---- INSPECT runtime functions ---- */

/* Find first occurrence of needle in haystack. Returns -1 if not found. */
static int find_substr(const char *haystack, unsigned int hay_len,
                       const char *needle, unsigned int ndl_len) {
    if (ndl_len == 0 || ndl_len > hay_len) return -1;
    for (unsigned int i = 0; i <= hay_len - ndl_len; i++) {
        if (memcmp(haystack + i, needle, ndl_len) == 0) return (int)i;
    }
    return -1;
}

void cobolrt_inspect_tallying(
    const char *data, unsigned int data_len,
    char *tally, unsigned int tally_len,
    unsigned int mode,
    const char *search, unsigned int search_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !tally) return;

    /* Read current tally value */
    long long tally_val = display_to_int(tally, tally_len);

    /* Determine effective range */
    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }
    if (start_pos >= end_pos) return;

    long long count = 0;
    if (mode == 0) {
        /* CHARACTERS */
        count = (long long)(end_pos - start_pos);
    } else if (mode == 1) {
        /* ALL */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                count++;
                i += search_len;
            } else {
                i++;
            }
        }
    } else if (mode == 2) {
        /* LEADING */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                count++;
                i += search_len;
            } else {
                break;
            }
        }
    }

    tally_val += count;
    int_to_display(tally_val, tally, tally_len);
}

void cobolrt_inspect_replacing(
    char *data, unsigned int data_len,
    unsigned int mode,
    const char *search, unsigned int search_len,
    const char *replacement, unsigned int replacement_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !replacement) return;

    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }
    if (start_pos >= end_pos) return;

    if (mode == 0) {
        /* CHARACTERS BY replacement */
        char repl_byte = replacement[0];
        for (unsigned int i = start_pos; i < end_pos; i++) {
            data[i] = repl_byte;
        }
    } else if (mode == 1) {
        /* ALL */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
                memcpy(data + i, replacement, copy_len);
                if (replacement_len < search_len) {
                    memset(data + i + replacement_len, ' ', search_len - replacement_len);
                }
                i += search_len;
            } else {
                i++;
            }
        }
    } else if (mode == 2) {
        /* LEADING */
        if (!search || search_len == 0) return;
        unsigned int i = start_pos;
        while (i + search_len <= end_pos) {
            if (memcmp(data + i, search, search_len) == 0) {
                unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
                memcpy(data + i, replacement, copy_len);
                if (replacement_len < search_len) {
                    memset(data + i + replacement_len, ' ', search_len - replacement_len);
                }
                i += search_len;
            } else {
                break;
            }
        }
    } else if (mode == 3) {
        /* FIRST */
        if (!search || search_len == 0) return;
        int pos = find_substr(data + start_pos, end_pos - start_pos, search, search_len);
        if (pos >= 0) {
            unsigned int abs_pos = start_pos + (unsigned int)pos;
            unsigned int copy_len = search_len < replacement_len ? search_len : replacement_len;
            memcpy(data + abs_pos, replacement, copy_len);
            if (replacement_len < search_len) {
                memset(data + abs_pos + replacement_len, ' ', search_len - replacement_len);
            }
        }
    }
}

void cobolrt_inspect_converting(
    char *data, unsigned int data_len,
    const char *from_chars, unsigned int from_len,
    const char *to_chars, unsigned int to_len,
    const char *before_initial, unsigned int before_initial_len,
    const char *after_initial, unsigned int after_initial_len
) {
    if (!data || !from_chars || !to_chars) return;

    unsigned int start_pos = 0;
    unsigned int end_pos = data_len;

    if (after_initial && after_initial_len > 0) {
        int pos = find_substr(data, data_len, after_initial, after_initial_len);
        if (pos >= 0) start_pos = (unsigned int)pos + after_initial_len;
        else start_pos = data_len;
    }
    if (before_initial && before_initial_len > 0) {
        int pos = find_substr(data, data_len, before_initial, before_initial_len);
        if (pos >= 0) end_pos = (unsigned int)pos;
    }

    for (unsigned int i = start_pos; i < end_pos; i++) {
        for (unsigned int j = 0; j < from_len; j++) {
            if (data[i] == from_chars[j]) {
                if (j < to_len) data[i] = to_chars[j];
                break;
            }
        }
    }
}

/* ---- UNSTRING per-field runtime function ---- */

void cobolrt_unstring_field(
    const char *source, unsigned int source_len,
    const char *delimiter, unsigned int delimiter_len,
    unsigned int all_delim,
    char *target, unsigned int target_len,
    char *pointer, unsigned int pointer_len,
    char *tally, unsigned int tally_len
) {
    if (!source || !target) return;

    /* Read the pointer value (1-based, display-format) */
    unsigned int start_pos = 0;
    if (pointer && pointer_len > 0) {
        long long pos = display_to_int(pointer, pointer_len);
        if (pos < 1) pos = 1;
        start_pos = (unsigned int)(pos - 1);
    }

    if (start_pos >= source_len) {
        /* Overflow: space-fill target */
        memset(target, ' ', target_len);
        return;
    }

    /* Find delimiter in remaining source */
    unsigned int field_end = source_len;
    unsigned int delim_skip = 0;

    if (delimiter && delimiter_len > 0) {
        int pos = find_substr(source + start_pos, source_len - start_pos,
                              delimiter, delimiter_len);
        if (pos >= 0) {
            field_end = start_pos + (unsigned int)pos;
            delim_skip = delimiter_len;

            /* If ALL, skip consecutive delimiters */
            if (all_delim) {
                unsigned int next = field_end + delimiter_len;
                while (next + delimiter_len <= source_len &&
                       memcmp(source + next, delimiter, delimiter_len) == 0) {
                    next += delimiter_len;
                    delim_skip += delimiter_len;
                }
            }
        }
    }

    /* Copy field into target, space-padded */
    unsigned int field_len = field_end - start_pos;
    memset(target, ' ', target_len);
    unsigned int copy_len = field_len < target_len ? field_len : target_len;
    memcpy(target, source + start_pos, copy_len);

    /* Update pointer */
    if (pointer && pointer_len > 0) {
        long long new_pos = (long long)(field_end + delim_skip + 1);
        int_to_display(new_pos, pointer, pointer_len);
    }

    /* Update tally */
    if (tally && tally_len > 0) {
        long long t = display_to_int(tally, tally_len);
        t++;
        int_to_display(t, tally, tally_len);
    }
}

/* ---- COMPUTE/PERFORM support: negate, decimal ops, counter support ---- */

/* Negate a display-format numeric value. Returns pointer to thread-local buffer. */
static char negate_buf[64];
char* cobolrt_negate_numeric(const char *data, unsigned int data_len) {
    if (!data || data_len == 0) return negate_buf;
    unsigned int out_len = data_len + 1;
    if (out_len > sizeof(negate_buf)) out_len = sizeof(negate_buf);
    negate_buf[0] = '-';
    unsigned int copy_len = out_len - 1 < data_len ? out_len - 1 : data_len;
    memcpy(negate_buf + 1, data, copy_len);
    return negate_buf;
}

/* Display-format decimal arithmetic for COMPUTE expressions.
   These return a pointer to a thread-local result buffer. */
static char decimal_result_buf[128];

static long long parse_display_val(const char *data, unsigned int len, int *scale) {
    long long val = 0;
    int neg = 0;
    *scale = 0;
    int past_dot = 0;
    for (unsigned int i = 0; i < len; i++) {
        if (data[i] == '-') { neg = 1; continue; }
        if (data[i] == '.') { past_dot = 1; continue; }
        if (data[i] >= '0' && data[i] <= '9') {
            val = val * 10 + (data[i] - '0');
            if (past_dot) (*scale)++;
        }
    }
    return neg ? -val : val;
}

static char* write_decimal_result(long long val, int scale) {
    int neg = 0;
    if (val < 0) { neg = 1; val = -val; }
    /* Write digits right-to-left */
    char tmp[64];
    int pos = 63;
    tmp[pos] = '\0';
    if (val == 0) { tmp[--pos] = '0'; if (scale > 0) { for (int s = 0; s < scale; s++) tmp[--pos] = '0'; tmp[--pos] = '.'; } }
    else {
        int digit_count = 0;
        long long v = val;
        while (v > 0) { tmp[--pos] = '0' + (v % 10); v /= 10; digit_count++; }
        /* Insert decimal point if needed */
        if (scale > 0 && scale < digit_count) {
            /* Shift digits to make room for dot */
            int dot_pos_from_right = scale;
            int result_len = digit_count + 1;
            char tmp2[64];
            int src = pos, dst = 0;
            for (int i = 0; i < digit_count - scale; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst++] = '.';
            for (int i = 0; i < scale; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst] = '\0';
            pos = 0;
            memcpy(tmp, tmp2, dst + 1);
        } else if (scale >= digit_count) {
            /* All digits are fractional: 0.00...digits */
            char tmp2[64];
            int dst = 0;
            tmp2[dst++] = '0';
            tmp2[dst++] = '.';
            for (int i = 0; i < scale - digit_count; i++) tmp2[dst++] = '0';
            int src = pos;
            for (int i = 0; i < digit_count; i++) tmp2[dst++] = tmp[src++];
            tmp2[dst] = '\0';
            pos = 0;
            memcpy(tmp, tmp2, dst + 1);
        }
    }
    int result_start = 0;
    if (neg) { decimal_result_buf[result_start++] = '-'; }
    int len = strlen(tmp + pos);
    memcpy(decimal_result_buf + result_start, tmp + pos, len);
    decimal_result_buf[result_start + len] = '\0';
    return decimal_result_buf;
}

char* cobolrt_decimal_add(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    /* Align scales */
    int max_scale = ls > rs ? ls : rs;
    while (ls < max_scale) { lv *= 10; ls++; }
    while (rs < max_scale) { rv *= 10; rs++; }
    return write_decimal_result(lv + rv, max_scale);
}

char* cobolrt_decimal_sub(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    int max_scale = ls > rs ? ls : rs;
    while (ls < max_scale) { lv *= 10; ls++; }
    while (rs < max_scale) { rv *= 10; rs++; }
    return write_decimal_result(lv - rv, max_scale);
}

char* cobolrt_decimal_mul(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    return write_decimal_result(lv * rv, ls + rs);
}

char* cobolrt_decimal_div(const char *left, unsigned int left_len,
                          const char *right, unsigned int right_len,
                          unsigned int result_len) {
    int ls = 0, rs = 0;
    long long lv = parse_display_val(left, left_len, &ls);
    long long rv = parse_display_val(right, right_len, &rs);
    if (rv == 0) return write_decimal_result(0, 0);
    /* Add extra precision for division */
    int extra = 4;
    for (int i = 0; i < extra; i++) lv *= 10;
    return write_decimal_result(lv / rv, ls - rs + extra);
}

char* cobolrt_decimal_pow(const char *base, unsigned int base_len,
                          const char *exp, unsigned int exp_len,
                          unsigned int result_len) {
    int bs = 0, es = 0;
    long long bv = parse_display_val(base, base_len, &bs);
    long long ev = parse_display_val(exp, exp_len, &es);
    /* Integer exponent only */
    while (es > 0) { ev /= 10; es--; }
    if (ev < 0) return write_decimal_result(0, 0);
    long long result = 1;
    int result_scale = 0;
    for (long long i = 0; i < ev; i++) {
        result *= bv;
        result_scale += bs;
    }
    return write_decimal_result(result, result_scale);
}

/* Convert integer to display-format in a buffer */
void cobolrt_int_to_display(long long val, char *dest) {
    /* Write 8-byte zero-padded display */
    if (val < 0) val = -val;
    for (int i = 7; i >= 0; i--) {
        dest[i] = '0' + (val % 10);
        val /= 10;
    }
}

/*
 * Format a numeric-edited field in-place.
 *
 * `data` already contains the raw numeric digits (with '.' inserted at the
 * correct position by cobolrt_move_numeric / int_to_display_edited).
 * This function walks the PIC string and applies editing:
 *   Z -> zero suppress (replace leading '0' with ' ')
 *   , -> insert comma (but suppress to ' ' if in zero-suppress zone)
 *   . -> keep literal decimal point (already present)
 *   $ -> insert dollar sign
 *   - -> insert '-' for negative, ' ' for positive
 *   + -> insert '+' for positive, '-' for negative
 *   9 -> keep digit as-is
 *
 * The PIC string and the data buffer have a 1:1 positional correspondence
 * (after expanding repetition counts).
 */
void cobolrt_format_numeric_edited(
    char *data, unsigned int data_len,
    const char *pic, unsigned int pic_len
) {
    if (!data || !pic || data_len == 0 || pic_len == 0) return;

    /* Step 1: Expand PIC string into individual characters.
     * E.g. "Z(4)9.99" -> "ZZZZ9.99" */
    char expanded[256];
    unsigned int exp_len = 0;
    for (unsigned int i = 0; i < pic_len && exp_len < sizeof(expanded); ) {
        char ch = pic[i];
        /* Uppercase the character */
        if (ch >= 'a' && ch <= 'z') ch = ch - 32;
        if (i + 1 < pic_len && pic[i + 1] == '(') {
            /* Parse repetition count */
            unsigned int start = i + 2;
            unsigned int end = start;
            while (end < pic_len && pic[end] != ')') end++;
            int count = 0;
            for (unsigned int k = start; k < end; k++) {
                count = count * 10 + (pic[k] - '0');
            }
            for (int k = 0; k < count && exp_len < sizeof(expanded); k++) {
                expanded[exp_len++] = ch;
            }
            i = end + 1;
        } else {
            expanded[exp_len++] = ch;
            i++;
        }
    }

    /* Skip 'S' characters (sign indicator, no storage) and 'V' (implied decimal) */
    char pic_chars[256];
    unsigned int pic_chars_len = 0;
    for (unsigned int i = 0; i < exp_len && pic_chars_len < sizeof(pic_chars); i++) {
        if (expanded[i] != 'S' && expanded[i] != 'V') {
            pic_chars[pic_chars_len++] = expanded[i];
        }
    }

    /* The pic_chars array should now have length == data_len.
     * Walk left-to-right. Track whether we are in the "zero suppress" zone.
     * Zero suppression is active from the start until we hit a significant
     * (non-zero) digit or pass the last Z position. */

    /* First, find the rightmost Z (or * or floating $+-) position.
     * Everything from position 0 to that position is the suppress zone. */
    int last_z_pos = -1;
    for (int i = (int)pic_chars_len - 1; i >= 0; i--) {
        if (pic_chars[i] == 'Z' || pic_chars[i] == '*') {
            last_z_pos = i;
            break;
        }
    }

    /* Determine if the value is zero (all digit positions are '0') */
    int is_all_zero = 1;
    int is_negative = 0;
    for (unsigned int i = 0; i < data_len; i++) {
        if (data[i] >= '1' && data[i] <= '9') {
            is_all_zero = 0;
        }
        /* Check for trailing overpunch negative indicators */
        if (data[i] >= 'p' && data[i] <= 'y') {
            is_negative = 1;
            is_all_zero = 0;
        }
    }

    /* Now walk left-to-right applying the edit */
    int suppressing = 1;  /* start in suppress mode */
    unsigned int d = 0;   /* index into data */

    for (unsigned int p = 0; p < pic_chars_len && d < data_len; p++) {
        char pc = pic_chars[p];
        switch (pc) {
            case '9':
                /* Always show digit, end suppression */
                suppressing = 0;
                d++;
                break;
            case 'Z':
                if (suppressing && data[d] == '0' && (int)p <= last_z_pos) {
                    data[d] = ' ';
                } else {
                    suppressing = 0;
                }
                d++;
                break;
            case '*':
                if (suppressing && data[d] == '0') {
                    data[d] = '*';
                } else {
                    suppressing = 0;
                }
                d++;
                break;
            case '.':
                /* Literal decimal point - already in data */
                d++;
                break;
            case ',':
                /* Comma insertion: if in suppress zone, replace with space */
                if (suppressing) {
                    data[d] = ' ';
                } else {
                    data[d] = ',';
                }
                d++;
                break;
            case '$':
                data[d] = '$';
                d++;
                break;
            case '-':
                if (is_negative) {
                    data[d] = '-';
                } else {
                    data[d] = ' ';
                }
                d++;
                break;
            case '+':
                if (is_negative) {
                    data[d] = '-';
                } else {
                    data[d] = '+';
                }
                d++;
                break;
            case 'B':
                data[d] = ' ';
                d++;
                break;
            case '/':
                data[d] = '/';
                d++;
                break;
            case '0':
                data[d] = '0';
                d++;
                break;
            default:
                d++;
                break;
        }
    }
}
"#;

/// cobolc -- The World's Best Open-Source COBOL Compiler
#[derive(Parser, Debug)]
#[command(name = "cobolc", version, about)]
struct Cli {
    /// Input COBOL source file(s)
    #[arg(required = true)]
    input: Vec<PathBuf>,

    /// Output file path
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Codegen backend to use
    #[arg(long, default_value = "cranelift", value_parser = ["llvm", "cranelift"])]
    backend: String,

    /// COBOL dialect
    #[arg(long, default_value = "cobol85", value_parser = ["cobol85", "ibm", "microfocus", "gnucobol"])]
    dialect: String,

    /// What to emit
    #[arg(long, default_value = "exe", value_parser = ["exe", "obj", "llvm-ir", "mir", "hir", "ast", "tokens", "preprocessed"])]
    emit: String,

    /// Optimization level
    #[arg(short = 'O', long = "opt-level", default_value = "0", value_parser = ["0", "1", "2", "3", "s"])]
    opt_level: String,

    /// Source format
    #[arg(long, default_value = "fixed", value_parser = ["fixed", "free"])]
    format: String,

    /// Copybook include directories
    #[arg(short = 'I', long = "include")]
    include_dirs: Vec<PathBuf>,

    /// Enable verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Dump internal representations for debugging
    #[arg(long)]
    dump: bool,
}

fn main() {
    let cli = Cli::parse();

    if cli.verbose {
        eprintln!("cobolc v{}", env!("CARGO_PKG_VERSION"));
        eprintln!("Backend: {}", cli.backend);
        eprintln!("Dialect: {}", cli.dialect);
        eprintln!("Format: {}", cli.format);
        eprintln!("Optimization: O{}", cli.opt_level);
    }

    // Set up the compilation database
    let mut db = cobol_db::SimpleDatabase::new();

    // Add copybook directories
    for dir in &cli.include_dirs {
        db.vfs_mut().add_copybook_dir(dir.clone());
    }

    // Determine source format
    let source_format = match cli.format.as_str() {
        "free" => cobol_lexer::SourceFormat::Free,
        _ => cobol_lexer::SourceFormat::Fixed,
    };

    // For exe/obj mode, accumulate object files across all inputs,
    // then link once at the end.
    let mut obj_files: Vec<PathBuf> = Vec::new();

    // Process each input file
    for input_path in &cli.input {
        // Load the source file
        let file_id = match db.vfs_mut().load_file(input_path) {
            Ok(id) => id,
            Err(e) => {
                eprintln!("error: {}", e);
                std::process::exit(1);
            }
        };

        // Get the source text
        let source = match db.vfs().file_content(file_id) {
            Some(s) => s.to_string(),
            None => {
                eprintln!("error: could not read file {:?}", input_path);
                std::process::exit(1);
            }
        };

        use cobol_db::InputDatabase;
        db.set_file_text(file_id, source.clone());
        db.set_source_format(file_id, source_format);

        // Run the preprocessor to expand COPY/REPLACE directives
        let pp_result = cobol_pp::preprocess(&source, file_id, db.vfs());
        let pp_text = pp_result.text.clone();

        if !pp_result.errors.is_empty() {
            for err in &pp_result.errors {
                eprintln!("warning: {}", err);
            }
        }

        // Run the pipeline based on --emit
        match cli.emit.as_str() {
            "preprocessed" => {
                print!("{}", pp_text);
            }
            "tokens" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                for token in &tokens {
                    if cli.dump {
                        println!("{:?}", token);
                    } else {
                        println!("{:?}: {:?}", token.kind, token.text);
                    }
                }
            }
            "ast" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                if cli.dump {
                    println!("{:#?}", parse_result.green);
                }
                for err in &parse_result.errors {
                    eprintln!("error: {}", err);
                }
            }
            "hir" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                let syntax = parse_result.syntax();
                let ast = cobol_ast::SourceFile::cast(syntax)
                    .expect("root node should be SOURCE_FILE");
                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner);
                if cli.dump {
                    println!("{:#?}", hir);
                }
                for diag in &hir.diagnostics {
                    eprintln!("{:?}: {}", diag.severity, diag.message);
                }
            }
            "mir" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                let syntax = parse_result.syntax();
                let ast = cobol_ast::SourceFile::cast(syntax)
                    .expect("root node should be SOURCE_FILE");
                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner);
                let mir = cobol_mir::lower(&hir, &interner);
                if cli.dump {
                    println!("{:#?}", mir);
                } else {
                    println!("MIR module: {} ({} functions, {} globals)",
                        mir.name, mir.functions.len(), mir.globals.len());
                }
            }
            "obj" | "exe" => {
                let tokens = cobol_lexer::lex(&pp_text, file_id, source_format);
                let parse_result = cobol_parser::parse(&tokens);
                for err in &parse_result.errors {
                    eprintln!("parse error: {}", err);
                }
                if !parse_result.errors.is_empty() && !cli.verbose {
                    eprintln!("warning: {} parse error(s); continuing anyway",
                        parse_result.errors.len());
                }

                let syntax = parse_result.syntax();
                let ast = cobol_ast::SourceFile::cast(syntax)
                    .expect("root node should be SOURCE_FILE");

                let mut interner = cobol_intern::Interner::new();
                let hir = cobol_hir::lower(&ast, &mut interner);
                for diag in &hir.diagnostics {
                    if diag.severity == cobol_hir::DiagnosticSeverity::Error {
                        eprintln!("error: {}", diag.message);
                    }
                }

                let mir = cobol_mir::lower(&hir, &interner);

                if cli.verbose {
                    eprintln!("MIR: {} functions, {} globals",
                        mir.functions.len(), mir.globals.len());
                }

                // Determine object file path
                let stem = input_path.file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("output");
                let obj_path = if cli.emit == "obj" && cli.input.len() == 1 {
                    cli.output.clone().unwrap_or_else(|| {
                        input_path.with_extension("o")
                    })
                } else {
                    // For exe or multi-file obj, use temp .o files
                    std::env::temp_dir().join(format!("{}.o", stem))
                };

                // Codegen
                use cobol_codegen_llvm::CodegenBackend;
                let backend: Box<dyn CodegenBackend> = match cli.backend.as_str() {
                    "cranelift" => Box::new(cobol_codegen_cranelift::CraneliftBackend::new()),
                    _ => {
                        eprintln!("error: LLVM backend not yet implemented, use --backend=cranelift");
                        std::process::exit(1);
                    }
                };

                if cli.verbose {
                    eprintln!("codegen backend: {}", backend.name());
                }

                if let Err(e) = backend.compile(&mir, &obj_path) {
                    eprintln!("error: codegen failed: {}", e);
                    std::process::exit(1);
                }

                if cli.verbose {
                    eprintln!("wrote object file: {}", obj_path.display());
                }

                obj_files.push(obj_path);
            }
            _ => {
                eprintln!("error: unknown --emit value: {}", cli.emit);
                eprintln!(
                    "hint: use --emit=tokens, --emit=ast, --emit=hir, --emit=mir, --emit=obj, or --emit=exe"
                );
                std::process::exit(1);
            }
        }
    }

    // After all files are compiled, link if exe mode
    if cli.emit == "exe" && !obj_files.is_empty() {
        let first_input = &cli.input[0];
        let exe_path = cli.output.clone().unwrap_or_else(|| {
            if cfg!(windows) {
                first_input.with_extension("exe")
            } else {
                first_input.with_extension("")
            }
        });

        // Write the C runtime shim to a temp file
        let runtime_c = std::env::temp_dir().join("cobolrt_shim.c");
        std::fs::write(&runtime_c, RUNTIME_SHIM_C).unwrap_or_else(|e| {
            eprintln!("error: failed to write runtime shim: {}", e);
            std::process::exit(1);
        });

        // Link all object files + runtime â†’ executable
        let mut cmd = std::process::Command::new("cc");
        for obj in &obj_files {
            cmd.arg(obj);
        }
        cmd.arg(&runtime_c)
            .arg("-o")
            .arg(&exe_path)
            .arg("-lc");

        let status = cmd.status();

        match status {
            Ok(s) if s.success() => {
                if cli.verbose {
                    eprintln!("linked executable: {}", exe_path.display());
                }
            }
            Ok(s) => {
                eprintln!("error: linker exited with status {}", s);
                std::process::exit(1);
            }
            Err(e) => {
                eprintln!("error: failed to run linker: {}", e);
                eprintln!("hint: ensure a C compiler (cc) is installed");
                std::process::exit(1);
            }
        }

        // Clean up temp files
        for obj in &obj_files {
            let _ = std::fs::remove_file(obj);
        }
        let _ = std::fs::remove_file(&runtime_c);
    }

    if cli.verbose {
        eprintln!("compilation complete");
    }
}
